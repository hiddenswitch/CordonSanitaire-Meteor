<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <link rel="stylesheet" type="text/css" href="mapboardcss.css">
</head>
<body>
<!--<form action="" method="GET">-->
<!--<input type="text" name="map">-->
<!--<input type="submit">-->
<!--</form>-->
<div id="edit">
    <div>Edit the map below (changes are automatically saved)
        <div id="edit-buttons-show-hide">
            <button id="start-edit">Start Editing</button>
        </div>
        <div id="edit-button">
            <button id="add">Add Roads</button>
            <button id="remove">Remove Roads</button>
            <button id="reset">Reset</button>
            <button id="done">Done</button>
        </div>
    </div>
</div>
<div id="cell-row-col"></div>
<div id="mapboard"></div>
<div id="scripts">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
    <script src="phaser.js"></script>
    <script type="text/javascript" src="dat.gui.js"></script>
    <div id="globalVariables">
        <script>
            var numCols = 10;
            var numRows = 10;
            var blockWidth = 5;
            var blockHeight = 5;
            var mapName;
            var currentMap;
            var density = 1;

            var cellSize = 10;
            var currentMapSafetyCopy;

        </script>
    </div>
    <script type="text/javascript" src="graphStuff.js"></script>
    <div id="mapGenerator">
        <script>
            /**
             * Created by Shinjini on 3/14/2016.
             */


            //        SanitaireMaps.PATHABLE_TILES = [8, 9, 10, 11, 12, 15, 17, 18, 33, 37, 38, 39];
            //
            //        SanitaireMaps.CROSSWALK_TILES = [8, 9, 10, 11];
            //
            //        0 = road
            //        1 = building
            //        2 = intersection


            /*
            5x5 tiles
            */
            var Blocks = {};
//            var Blocks = {
//                SOLID :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                VERTICAL :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                HORIZONTAL :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                PLUS :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                T_LEFT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                T_RIGHT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                T_UP :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                T_DOWN :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                UP_LEFT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                UP_RIGHT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 0, 0],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                DOWN_RIGHT :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                DOWN_LEFT :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [0, 0, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ]
//
//            };
            var prettyPrint = function(block){
                var print = '';
                for (var i = 0; i<block.length; i++){
                    for (var j = 0; j<block[0].length; j++){
                        print = print.concat(block[i][j]);
                    }
                    print = print.concat("\n");
                }
                console.log(print);
            };



            var blockMaker = function (rowSize, colSize, up, right, down, left){


                var block = [];
                for (var i=0; i<rowSize; i++){
                    block.push([]);
                    for (var j = 0; j<colSize; j++){
                        block[i].push(IMPASSABLE);
                    }
                }
                var rowNum = Math.floor((rowSize-1)/2);
                var colNum = Math.floor((colSize-1)/2);

                if (up){
                    for (var i = 0; i<rowNum+1; i++){
                        block[i][colNum] = STRAIGHT_ROAD;
                    }
                }
                if (down){
                    for (var i = rowNum; i<rowSize; i++){
                        block[i][colNum] = STRAIGHT_ROAD;
                    }
                }
                if (left){
                    for (var i = 0; i<colNum+1; i++){
                        block[rowNum][i] = STRAIGHT_ROAD;
                    }
                }
                if (right){
                    for (var i = colNum; i<colSize; i++){
                        block[rowNum][i] = STRAIGHT_ROAD;
                    }
                }
                return block;
            };

            var BlockTypesMaker = function(rowSize, colSize){
                // up, right, down, left
                Blocks.SOLID = blockMaker(rowSize,colSize,false, false, false, false);

                Blocks.VERTICAL = blockMaker(rowSize,colSize,true, false, true, false);
                Blocks.HORIZONTAL = blockMaker(rowSize,colSize,false, true, false, true);

                Blocks.T_UP = blockMaker(rowSize,colSize,true, true, false, true);
                Blocks.T_RIGHT = blockMaker(rowSize,colSize,true, true, true, false);
                Blocks.T_DOWN = blockMaker(rowSize,colSize,false, true, true, true);
                Blocks.T_LEFT = blockMaker(rowSize,colSize,true, false, true, true);

                Blocks.UP_LEFT = blockMaker(rowSize,colSize,true, false, false, true);
                Blocks.UP_RIGHT = blockMaker(rowSize,colSize,true, true, false, false);
                Blocks.DOWN_LEFT = blockMaker(rowSize,colSize,false, false, true, true);
                Blocks.DOWN_RIGHT = blockMaker(rowSize,colSize,false, true, true, false);
                Blocks.PLUS = blockMaker(rowSize,colSize,true, true, true, true);

            };

            // weights do no have to add to 1, the will be normalized in all cases
            var PathToRight = {
                YES: {
                    "SOLID":0,
                    "HORIZONTAL":1,
                    "PLUS":1,
                    "T_LEFT":1,
                    "T_UP":1,
                    "T_DOWN":1,
                    "UP_LEFT":1,
                    "DOWN_LEFT":1
                },
                NO: {
                    "SOLID":1,
                    "VERTICAL":1,
                    "T_RIGHT":1,
                    "UP_RIGHT":1,
                    "DOWN_RIGHT":1
                }
            }

            var PathDown = {
                YES: {
                    "SOLID":0,
                    "VERTICAL":1,
                    "PLUS":1,
                    "T_LEFT":1,
                    "T_RIGHT":1,
                    "T_UP":1,
                    "UP_LEFT":1,
                    "UP_RIGHT":1
                },
                NO: {
                    "SOLID":1,
                    "HORIZONTAL":1,
                    "T_DOWN":1,
                    "DOWN_RIGHT":1,
                    "DOWN_LEFT":1
                }
            }

            var BlockSuccessors = {
                "SOLID": {
                    right: PathToRight.NO,
                    down: PathDown.NO
                },
                "VERTICAL":{
                    right: PathToRight.NO,
                    down: PathDown.YES
                },
                "HORIZONTAL":{
                    right: PathToRight.YES,
                    down: PathDown.NO
                },
                "PLUS":{
                    right: PathToRight.YES,
                    down: PathDown.YES
                },
                "T_LEFT":{
                    right: PathToRight.NO,
                    down: PathDown.YES
                },
                "T_RIGHT":{
                    right: PathToRight.YES,
                    down:PathDown.YES
                },
                "T_UP":{
                    right: PathToRight.YES,
                    down: PathDown.NO
                },
                "T_DOWN":{
                    right: PathToRight.YES,
                    down: PathDown.YES
                },
                "UP_LEFT":{
                    right: PathToRight.NO,
                    down: PathDown.NO
                },
                "UP_RIGHT":{
                    right: PathToRight.YES,
                    down:PathDown.NO
                },
                "DOWN_RIGHT":{
                    right: PathToRight.YES,
                    down: PathDown.YES
                },
                "DOWN_LEFT":{
                    right: PathToRight.NO,
                    down: PathDown.YES
                }
            };

            /*
             Generates a conceptual map based on descriptions of crossings.
             For example,

                |_|

                11011 11111 11011
                11011 11111 11011
                11000 00000 00011
                11111 11111 11111
                11111 11111 11111

             would be:
                [["UP_RIGHT", "HORIZONTAL", "UP_LEFT"]
             */
            var mapDescriptionGenerate = function(mapRows, mapCols){
                // 50x50 is 10x10 blocks

                // If at (row, col) = (0, 0), pretend that up and left are SOLID
                // If row = 0, pretend up is SOLID
                // If col = 0, pretend left is SOLID
                var map = [];
                for (var row = 0; row < mapRows; row++){
                    map.push([])
                    var up; // these are strings eg, "SOLID"
                    var left;
                    for (var col = 0; col< mapCols; col++){
                        if (row  == 0){
                            if (col ==0){ // if (i, j) = (0, 0)
                                up = "SOLID";
                                left = "SOLID";
                            } else {
                                up = "SOLID";
                                left = map[row][col-1];
                            }
                        }
                        else if (col == 0){ // will not have the case (i, j) = (0, 0)
                            up = map[row-1][col];
                            left = "SOLID";
                        } else { // all other cases
                            up = map[row-1][col];
                            left = map[row][col-1];
                        }
                        // find intersection
                        var possibilitiesFromUp = BlockSuccessors[up].down;
                        var possibilitiesFromUpKeys = Object.keys(possibilitiesFromUp);
                        var possibilitiesFromLeft = BlockSuccessors[left].right;
                        var possibilities = {};
                        var sumProbabilities = 0;

                        // edge cases
                        var edgeCase = false;
                        if (row == mapRows -1){
                            edgeCase = true;
                            if (col == mapCols - 1){ // bottom right cell
                                var allowed = {
                                    "SOLID":1,
                                    "UP_LEFT":1
                                }
                            } else { // bottom row
                                var allowed = {
                                    "SOLID":1,
                                    "HORIZONTAL":1,
                                    "T_UP": 1,
                                    "UP_RIGHT":1,
                                    "UP_LEFT":1
                                }
                            }
                        } else if (col == mapCols -1){ // rightmost Column
                            edgeCase = true;
                            var allowed = {
                                "SOLID":1,
                                "VERTICAL":1,
                                "T_LEFT":1,
                                "UP_LEFT":1,
                                "DOWN_LEFT":1
                            }
                        }
                        if (edgeCase){
                            var allowedKeys = Object.keys(allowed);
                            for (var i = 0; i<allowedKeys.length; i++){
                                var key = allowedKeys[i];
                                if ((key in possibilitiesFromLeft)&&(key in possibilitiesFromUp)) {
                                    var probability = allowed[key] * possibilitiesFromLeft[key] * possibilitiesFromUp[key];
                                    sumProbabilities += probability;
                                    possibilities[key] = probability;
                                }
                            }
                        } else {
                            for (var i = 0; i<possibilitiesFromUpKeys.length; i++){
                                var key = possibilitiesFromUpKeys[i];
                                if (key in possibilitiesFromLeft){
                                    var probability = possibilitiesFromLeft[key]*possibilitiesFromUp[key];
                                    sumProbabilities += probability;
                                    possibilities[key] = probability;
                                }
                            }
                        }
                        var possibilitiesKeys = Object.keys(possibilities);
                        var possibilitiesProbRanges = [];
                        var probRange = 0;
                        for (var i = 0; i<possibilitiesKeys.length; i++){
                            var key = possibilitiesKeys[i];
                            var newProb = possibilities[key]/sumProbabilities;
                            possibilities[key] = newProb; // don't actually need to do this
                            probRange += newProb;
                            possibilitiesProbRanges.push(probRange);
                        }

                        // get random number
                        var rand = Math.random();
                        var index;
                        for (var i = 0; i<possibilitiesKeys.length; i++){
                            if (rand<possibilitiesProbRanges[i]){
                                index = i;
                                break;
                            }
                        }
                        var newBlock = possibilitiesKeys[index];
                        if (!newBlock){
                            newBlock = "SOLID"; // sometimes happens for the last cell
                        }
                        map[row].push(newBlock);
                    }
                }
                return map
            };

            var emptyMapDescriptionGenerate = function(mapRows, mapCols) {
                var map = [];
                for (var row = 0; row < mapRows; row++) {
                    map.push([])
                    for (var col = 0; col < mapCols; col++) {
                        map[row].push("SOLID");
                    }
                }
                return map;
            };

            var emptyMapGenerate = function(numRows, numCols){
                return mapDecode(emptyMapDescriptionGenerate(numRows, numCols));
            }

            /*
                Decodes a mapdescription to produce an array of 0-1 which represents the map
             */
            var mapDecode = function(mapDescription){
                var data = [];
                for (var rowNum = 0; rowNum<mapDescription.length; rowNum++){
                    for (var blockRowNum = 0; blockRowNum<blockHeight; blockRowNum++){
                        var rowData = [];
                        for (var colNum = 0; colNum<mapDescription[rowNum].length; colNum++){
                            var description = mapDescription[rowNum][colNum];
                            var descriptionArray = Blocks[description];
                            rowData = rowData.concat(descriptionArray[blockRowNum]);
                        }
                        data.push(rowData);
                    };
                }
                return data;
            };

            /*
                Generates a random numRows*numCols map
             */
            var mapGenerate = function(numRows, numCols){
                var mapEmpty = true;
                while (mapEmpty){
                    var map = mapDecode(mapDescriptionGenerate(numRows, numCols));
                    if ((map.length === Blocks.SOLID.length)&&(map[0].length === Blocks.SOLID.length)){ // for the 5x5 map that will always be empty
                        break;
                    }
                    for (var i = 0; i<map.length; i++){
                        for (var j = 0; j<map[0].length; j++){
                            if (map[i][j] === STRAIGHT_ROAD){
                                mapEmpty = false;
                            }
                        }
                    }
                }
                combineDisconnected(map);
                markIntersections(map);
                return map;
            }

            /** http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
             * Randomize array element order in-place.
             * Using Durstenfeld shuffle algorithm.
             */
            function shuffleArray(array) {
                for (var i = array.length - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    var temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
                return array;
            }

            // mutates
            var combineDisconnected = function(map){
                var components = findComponents(map, TileType.PASSABLE);
                if (components.length>1){
                    shuffleArray(components);
                    for (var compNum = 0; compNum < components.length-1; compNum++){
                        var first = components[compNum];
                        var second = components[compNum+1];
                        // select a point in 1st and 2nd component
                        // join them
                        var point1 = first[Math.floor(first.length/2)];
                        var point2 = second[Math.floor(second.length/2)];
                        var x1 = point1[1];
                        var y1 = point1[0];
                        var x2 = point2[1];
                        var y2 = point2[0];

                        var center = findBlockCenter(map, y1, x1);
                        if (center===undefined){
                            console.log("point1", y1, x1, center);
                        }
                        x1 = center[1];
                        y1 = center[0];
                        center = findBlockCenter(map, y2, x2);
                        if (center===undefined){
                            console.log("point2",y2, x2, center);
                        }

                        x2 = center[1];
                        y2 = center[0];

                        var x_start;
                        var x_end;
                        var y_start;
                        var y_end;
                        var x_hold;
                        var y_hold;
                        if (x1<x2){
                            x_start = x1;
                            x_end = x2;
                        } else {
                            x_start = x2;
                            x_end = x1;
                        }
                        if (y1<y2){
                            y_start = y1;
                            y_end = y2;
                        } else {
                            y_start = y2;
                            y_end = y1;
                        }

                        if ((x1<x2 && y1<y2) || (x2<x1 && y2<y1)){ //low high
                            x_hold = x_start;
                            y_hold = y_end;
                        } else{ //low low
                            x_hold = x_start;
                            y_hold = y_start;
                        }


                        for (var i = x_start; i<x_end+1; i++){
                            if (map[y_hold][i] === IMPASSABLE){
                                map[y_hold][i] = STRAIGHT_ROAD; // use 5 for debugging
                            }
                        }

                        for (var j = y_start; j<y_end+1; j++){
                            if (map[j][x_hold] === IMPASSABLE){
                                map[j][x_hold] = STRAIGHT_ROAD; // use 5 for debugging
                            }
                        }
                    }
                }

            };

            var findBlockCenter = function(map, row, col){
                if (row>map.length-1 || row<0){
                    return [];
                }
                if (col>map[0].length-1 || col<0){
                    return [];
                }
                var blockHeight = Blocks.SOLID.length;
                var blockWidth = Blocks.SOLID[0].length;
                var row_start = row - Math.floor((blockHeight-1)/2);
                var col_start = col - Math.floor((blockWidth-1)/2);
                var row_end = row + Math.ceil((blockHeight-1)/2);
                var col_end = col + Math.ceil((blockWidth-1)/2);
                if (row_start<0){
                    row_start = 0;
                }
                if (row_end>map.length-1){
                    row_end = map.length-1;
                }
                if (col_start<0){
                    col_start = 0;
                }
                if (col_end>map[0].length-1){
                    col_end = map[0].length-1;
                }
                for (var i = row_start; i<row_end+1; i++){
                    for (var j = col_start; j<col_end+1; j++){
                        if ((i%blockHeight)=== Math.floor((blockHeight-1)/2) &&
                                (j%blockWidth)=== Math.floor((blockWidth-1)/2)){ //if i and j are in the middle of the block
                            if (map[i][j] === STRAIGHT_ROAD){
                                return [i,j]
                            }
                        }
                    }
                }
                return [];
            }

//            // i = row; j = col
//            var checkIntersection = function(map, i, j){
//                var up    = 2
//                var down  = 3
//                var left  = 5
//                var right = 7
//
//                var tileType = TileType.PASSABLE;
//                var ID = -1;
//                if (tileType.has(map[i][j])){
//                    if ((i>0) && tileType.has(map[i-1][j])){//up
//                        if ((j>0) && tileType.has(map[i][j-1])){//left
//                            return true;
//                        }
//                        if ((j<map[0].length-1) && tileType.has(map[i][j+1])){//right
//                            return true;
//                        }
//                    }
//                    if ((i<map.length-1) && tileType.has(map[i+1][j])){//down
//                        if ((j>0) && tileType.has(map[i][j-1])){//left
//                            return true;
//                        }
//                        if ((j<map[0].length-1) && tileType.has(map[i][j+1])){//right
//                            return true;
//                        }
//                    }
//                }
//                return false;
//            }

            // i = row; j = col
            var checkIntersection = function(map, i, j){
                var up    = 2;
                var down  = 3;
                var left  = 5;
                var right = 7;

                var tileType = TileType.PASSABLE;
                var ID = -1;
                if (tileType.has(map[i][j])){
                    if ((i>0) && tileType.has(map[i-1][j])) {//up
                        ID *= up;
                    }
                    if ((j>0) && tileType.has(map[i][j-1])){//left
                        ID *= left;
                    }
                    if ((j<map[0].length-1) && tileType.has(map[i][j+1])){//right
                        ID *= right;
                    }
                    if ((i<map.length-1) && tileType.has(map[i+1][j])){//down
                        ID *= down;
                    }
                }
                if ((ID != -1) && (ID in INTERSECTION2)){
                    return [true, ID]  // ID is new map value
                }
                return [false, map[i][j]]; // just return the old value
            }

            var checkIntersectionOfSurroundings = function(map, i, j){
                var own = checkIntersection(map, i, j);
                var up = checkIntersection(map, i-1, j);
                var down = checkIntersection(map, i+1, j);
                var left = checkIntersection(map, i, j-1);
                var right = checkIntersection(map, i, j+1);

                return [own, up, down, left, right];
            };

            // mutates
            var markIntersections = function(map){

                for (var i = 0; i< map.length; i++){ // i is y is row
                    for (var j = 0; j<map[0].length; j++){ // j is x is col
                        var [isIntersection, intersectionID] = checkIntersection(map, i, j);
                        if(isIntersection){
                            map[i][j] = intersectionID;
                        }
                    }
                }
            }

        </script>
    </div>

    <div id="displayMap">
        <script>
            /*
                displays the map as a canvas element inside #mapboard
            */
            var displayMap = function(map){

                $("#mapboard").html("");
                var width = map[0].length;         // width in pixels
                var height = map.length;


                var makeCell = function(color, row, col){
                    return "<div class='"+color+" cell' data-row='"+row+"' data-col='"+col+"' style='height:"+cellSize+"px;width:"+cellSize+"px;'></div>";

                }
                var mapDrawing = "<div id='mapContainer'>";
                for (var j=0; j<width; j++){
                    mapDrawing = mapDrawing.concat("<div class='col'>");
                    for (var i=0; i<height; i++){
                        mapDrawing = mapDrawing.concat("<div class='row'>");
                        if (TileType.PASSABLE.has(map[i][j])){
                            if(map[i][j] === 5){ //debugging
                                mapDrawing = mapDrawing.concat(makeCell("white",i,j));
                            } else if (map[i][j] in INTERSECTION2){ // intersection
                                mapDrawing = mapDrawing.concat(makeCell("black2",i,j));
                            } else {
                                mapDrawing = mapDrawing.concat(makeCell("black",i,j));
                            }
                        } else {
                            mapDrawing = mapDrawing.concat(makeCell("grey",i,j));
                        }
                        mapDrawing = mapDrawing.concat("</div>");
                    }
                    mapDrawing = mapDrawing.concat("</div>");
                }
                mapDrawing = mapDrawing.concat("</div>");
                $("#mapboard").html(mapDrawing);
            }
            
        </script>
    </div>
    <div id="manualMapEdit">
        <script type="text/javascript">
            $(function(){
                $('#start-edit').click(function(){
                    $('#edit-buttons-show-hide').css({
                        display: 'none'
                    });
                    $('#edit-button').css({
                        display: 'block'
                    });
                })

                var editingAdd = false;
                var editingRemove = false;


                var dragging = false;

                $("#reset").prop("disabled",true);

                $("#add").click(function(){
                    editingAdd = true;
                    editingRemove = false;
                    $("#add").prop("disabled",true);
                    $("#remove").prop("disabled",false);
                    $("#reset").prop("disabled",false);
                });
                $("#remove").click(function(){
                    editingAdd = false;
                    editingRemove = true;
                    $("#add").prop("disabled",false);
                    $("#remove").prop("disabled",true);
                    $("#reset").prop("disabled",false);
                });

                $("#reset").click(function(){
                    editingAdd = false;
                    editingRemove = false;
                    $("#add").prop("disabled",false);
                    $("#remove").prop("disabled",false);
                    $("#reset").prop("disabled",true);
                    currentMap = $.extend(true, [], currentMapSafetyCopy);
                    displayMap(currentMap);
                });

                $("#done").click(function(){
                    editingAdd = false;
                    editingRemove = false;
                    $("#add").prop("disabled",false);
                    $("#remove").prop("disabled",false);
                    $("#reset").prop("disabled",true);
                    currentMapSafetyCopy = $.extend(true, [], currentMap);

                    // hide away edit options
                    $('#edit-buttons-show-hide').css({
                        display: 'block'
                    });
                    $('#edit-button').css({
                        display: 'none'
                    });
                });

                $("body").on("mousedown","#mapContainer", function(evt){
                    evt.preventDefault();
                    if (editingAdd || editingRemove){
                        dragging = true;
                    }
                });

                $("body").on("mouseup","#mapContainer", function(evt){
                    evt.preventDefault();
                    dragging = false;
                });

                $("body").on("mousemove ",".cell", function(evt) {
                    evt.preventDefault();

                    var row = $(this).data("row");
                    var col = $(this).data("col");
                    if (dragging) {
                        if (editingAdd) {
                            $(this).removeClass();
                            $(this).addClass("cell").addClass("black");
                            currentMap[row][col] = STRAIGHT_ROAD;
                            var newIntersections = checkIntersectionOfSurroundings(currentMap, row, col);
                            if (newIntersections[0][0]){ // own
                                $(this).removeClass();
                                $(this).addClass("cell").addClass("black2");
                                currentMap[row][col] = newIntersections[0][1];
                            }
                            if (newIntersections[1][0]){ //up
                                $("[data-row='"+(row-1)+"'][data-col='"+col+"']").removeClass();
                                $("[data-row='"+(row-1)+"'][data-col='"+col+"']").addClass("cell").addClass("black2");
                                currentMap[row-1][col] = newIntersections[1][1];
                            }
                            if (newIntersections[2][0]){ //down
                                $("[data-row='"+(row+1)+"'][data-col='"+col+"']").removeClass();
                                $("[data-row='"+(row+1)+"'][data-col='"+col+"']").addClass("cell").addClass("black2");
                                currentMap[row+1][col] = newIntersections[2][1];
                            }
                            if (newIntersections[3][0]){ //left
                                $("[data-row='"+row+"'][data-col='"+(col-1)+"']").removeClass();
                                $("[data-row='"+row+"'][data-col='"+(col-1)+"']").addClass("cell").addClass("black2");
                                currentMap[row][col-1] = newIntersections[3][1];
                            }
                            if (newIntersections[4][0]){ //right
                                $("[data-row='"+row+"'][data-col='"+(col+1)+"']").removeClass();
                                $("[data-row='"+row+"'][data-col='"+(col+1)+"']").addClass("cell").addClass("black2");
                                currentMap[row][col+1] = newIntersections[4][1];
                            }
                        } else if (editingRemove) {
                            $(this).removeClass();
                            $(this).addClass("cell").addClass("grey");
                            currentMap[row][col] = IMPASSABLE;
                            var newIntersections = checkIntersectionOfSurroundings(currentMap, row, col);
                            // if intersections need to be removed
                            if (!newIntersections[1][0]){ //up
                                $("[data-row='"+(row-1)+"'][data-col='"+col+"']").removeClass();

                                if (TileType.PASSABLE.has(currentMap[row-1][col])){
                                    currentMap[row-1][col] = STRAIGHT_ROAD;
                                    $("[data-row='"+(row-1)+"'][data-col='"+col+"']").addClass("cell").addClass("black");
                                } else {
                                    currentMap[row-1][col] = IMPASSABLE;
                                    $("[data-row='"+(row-1)+"'][data-col='"+col+"']").addClass("cell").addClass("grey");
                                }
                            }
                            if (!newIntersections[2][0]){ //down
                                $("[data-row='"+(row+1)+"'][data-col='"+col+"']").removeClass();

                                if (TileType.PASSABLE.has(currentMap[row+1][col])){
                                    currentMap[row+1][col] = STRAIGHT_ROAD;
                                    $("[data-row='"+(row+1)+"'][data-col='"+col+"']").addClass("cell").addClass("black");
                                } else {
                                    currentMap[row+1][col] = IMPASSABLE;
                                    $("[data-row='"+(row+1)+"'][data-col='"+col+"']").addClass("cell").addClass("grey");
                                }
                            }
                            if (!newIntersections[3][0]){ //left
                                $("[data-row='"+row+"'][data-col='"+(col-1)+"']").removeClass();

                                if (TileType.PASSABLE.has(currentMap[row][col-1])){
                                    currentMap[row][col-1] = STRAIGHT_ROAD;
                                    $("[data-row='"+row+"'][data-col='"+(col-1)+"']").addClass("cell").addClass("black");
                                } else {
                                    currentMap[row][col-1] = IMPASSABLE;
                                    $("[data-row='"+row+"'][data-col='"+(col-1)+"']").addClass("cell").addClass("grey");
                                }
                            }
                            if (!newIntersections[4][0]){ //right
                                $("[data-row='"+row+"'][data-col='"+(col+1)+"']").removeClass();

                                if (TileType.PASSABLE.has(currentMap[row][col+1])){
                                    currentMap[row][col+1] = STRAIGHT_ROAD;
                                    $("[data-row='"+row+"'][data-col='"+(col+1)+"']").addClass("cell").addClass("black");
                                } else {
                                    currentMap[row][col+1] = IMPASSABLE;
                                    $("[data-row='"+row+"'][data-col='"+(col+1)+"']").addClass("cell").addClass("grey");
                                }
                            }
                        }
                    }

                });
            });








        </script>
    </div>
    <div id="dat.gui">
        <script type="text/javascript">
            /*
                height, width integer
             */
            var createNewMap = function(height, width){
//                var mapHeight =
                var map = mapGenerate(height,width);
                currentMap = map;
                displayMap(map);
            };

            var mapTweeker = function() {
                this.mapNameToSave = "newMap";
                this.mapNameToLoad = "test12";
                this.cellSize = cellSize;

                this.numCols = numCols;
                this.numRows = numRows;
                this.blockWidth = blockWidth;
                this.blockHeight = blockHeight;
                this.density = 0;
                this.deadends = false;
                this.resizeCurrent = function(){
                    cellSize = this.cellSize;
                    displayMap(currentMap);
                };
                this.update = function(){
                    density = this.density;
                    if (density === 0){
                        density = 1;
                    } else if (density<0){
                        density = 10/(-density);
                    } else {
                        density = 5*density;
                    }
                    if (this.deadends){
                        PathDown.YES.SOLID = .5;
                        PathToRight.YES.SOLID = .5;
                    } else {
                        PathDown.YES.SOLID = 0;
                        PathToRight.YES.SOLID = 0;
                    }
                    PathDown.YES.VERTICAL = 2/density;
                    PathDown.NO.HORIZONTAL = 2/density;
                    PathToRight.YES.HORIZONTAL = 2/density;
                    PathToRight.NO.VERTICAL = 2/density;
                    PathDown.NO.SOLID = 5/density;
                    PathToRight.NO.SOLID = 5/density;

                    blockHeight = Math.round(this.blockHeight);
                    blockWidth = Math.round(this.blockWidth);
                    BlockTypesMaker(blockHeight,blockWidth);
                    cellSize = this.cellSize;
                    numRows = Math.round(this.numRows);
                    numCols = Math.round(this.numCols);
                    createNewMap(numRows,numCols);
                    currentMapSafetyCopy  = $.extend(true, [], currentMap);
                };
                this.load = function(){
                    mapName = this.mapNameToLoad;
                    $.get(mapName + ".csv", function(data) {
                        var rows = data.split("\n");

                        var parsedMap = [];
                        for (var i = 0; i<rows.length-1; i++){
                            var cols = rows[i].split(",");
                            parsedMap.push(cols);
                            for (var j = 0; j<parsedMap[i].length;j++){
                                parsedMap[i][j] = parseInt(parsedMap[i][j]);
                            }
                        }

                        currentMap = parsedMap;
                        // display parsed map
                        displayMap(parsedMap);
                        currentMapSafetyCopy  = $.extend(true, [], currentMap);
                    });



                };

                this.loadEmptyMap = function(){
                    currentMap = emptyMapGenerate(numRows, numCols);
                    displayMap(currentMap);
                    currentMapSafetyCopy  = $.extend(true, [], currentMap);

                }
                this.save = function(){
                    var csvContent = "data:text/csv;charset=utf-8,";
                    currentMap.forEach(function(infoArray, index){
                        dataString = infoArray.join(",");
                        csvContent += index < currentMap.length ? dataString+ "\n" : dataString;

                    });


                    var encodedUri = encodeURI(csvContent);
                    var link = document.createElement("a");
                    link.setAttribute("href", encodedUri);
                    var name = this.mapNameToSave;
                    if (!name){
                        var millis = new Date();
                        var filename = "cs_map_" + millis.getTime() + ".csv";
                    } else {
                        var filename = name + ".csv";
                    }

                    link.setAttribute("download", filename);

                    link.click(); // This will download the data file named "{file name}.csv".

                };
            };
        </script>
    </div>
    <div id="queryString">
        <script>
            var QueryString = function () {
                // This function is anonymous, is executed immediately and
                // the return value is assigned to QueryString!
                var query_string = {};
                var query = window.location.search.substring(1);
                var vars = query.split("&");
                for (var i=0;i<vars.length;i++) {
                    var pair = vars[i].split("=");
                    // If first entry with this name
                    if (typeof query_string[pair[0]] === "undefined") {
                        query_string[pair[0]] = decodeURIComponent(pair[1]);
                        // If second entry with this name
                    } else if (typeof query_string[pair[0]] === "string") {
                        var arr = [ query_string[pair[0]],decodeURIComponent(pair[1]) ];
                        query_string[pair[0]] = arr;
                        // If third or later entry with this name
                    } else {
                        query_string[pair[0]].push(decodeURIComponent(pair[1]));
                    }
                }
                return query_string;
            }();
        </script>
    </div>
    <script>
        window.onload = function() {
            var mapTweekerUI = new mapTweeker();
            var gui = new dat.GUI();

            var f1 = gui.addFolder("tweek");
            f1.add(mapTweekerUI, 'mapNameToSave');



            f1.add(mapTweekerUI, 'numRows', 1, 20);
            f1.add(mapTweekerUI, 'numCols', 1, 20);

            f1.add(mapTweekerUI, 'blockHeight', 1, 20);
            f1.add(mapTweekerUI, 'blockWidth', 1, 20);

            f1.add(mapTweekerUI, 'density', -10, 10);
            f1.add(mapTweekerUI, 'deadends');

            f1.add(mapTweekerUI, 'update');
            f1.add(mapTweekerUI, 'save');


            var f3 = gui.addFolder("resize");
            f3.add(mapTweekerUI, 'cellSize', 1, 20);
            f3.add(mapTweekerUI, 'resizeCurrent');

            var f2 = gui.addFolder("load");
            f2.add(mapTweekerUI, 'mapNameToLoad');
            f2.add(mapTweekerUI, 'load');
            f2.add(mapTweekerUI, 'loadEmptyMap');

            f1.closed = false;
            f2.closed = false;
            f3.closed = false;

            BlockTypesMaker(blockHeight,blockWidth);
            createNewMap(numRows, numCols);
            currentMapSafetyCopy  =$.extend(true, [], currentMap);

        };
    </script>
</div>
<div id="show-row-col">
    <script>
        $(function(){
            $('body').on('mouseenter', '.cell', function(event){
                var row = $(this).data("row");
                var col = $(this).data("col");
                var x= $(this).position().left;
                var y= $(this).position().top;
                $("#cell-row-col").html("("+row+","+col+")");
                $("#cell-row-col").css({
                    display: 'block',
                    position: 'absolute',
                    top: y-20,
                    left: x+20
                })
            });
            $('body').on('mouseleave', '#mapContainer', function(event){
                $("#cell-row-col").css({
                    display: 'none',
                })
            });
        });
    </script>
</div>
</body>
</html>