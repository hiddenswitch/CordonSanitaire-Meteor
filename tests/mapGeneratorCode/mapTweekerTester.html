<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <link rel="stylesheet" type="text/css" href="mapboardcss.css">
</head>
<body>
<!--<form action="" method="GET">-->
<!--<input type="text" name="map">-->
<!--<input type="submit">-->
<!--</form>-->
<div id="edit">
    <div>Edit the map below (changes are automatically saved)
        <div id="edit-buttons-show-hide">
            <button id="start-edit" class="edit-btn">Edit</button>
        </div>
        <div id="edit-button">
            <button id="add" class="edit-btn">Add Roads</button>
            <button id="remove" class="edit-btn">Remove Roads</button>
            <button id="reset" class="edit-btn">Reset</button>
            <button id="done" class="edit-btn">Done</button>
        </div>
    </div>
</div>
<div id="cell-row-col"></div>
<div id="mapboard"></div>
<div id="scripts">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
    <script src="phaser.js"></script>
    <script type="text/javascript" src="dat.gui.js"></script>
    <div id="globalVariables">
        <script>
            var numTilesCol = 40;
            var numTilesRow = 50;
            var blockWidth = 8;
            var blockHeight = 8;
            var numCols = Math.floor(numTilesCol/blockWidth);
            var numRows = Math.floor(numTilesRow/blockHeight);
            var mapName;
            var currentMap;
            var density = 1;

            var cellSize = 9;
            var currentMapSafetyCopy;
            var unpaddedMap;

        </script>
    </div>
    <script type="text/javascript" src="graphStuff.js"></script>
    <div id="mapGenerator">
        <script>
            /**
             * Created by Shinjini on 3/14/2016.
             */


            //        SanitaireMaps.PATHABLE_TILES = [8, 9, 10, 11, 12, 15, 17, 18, 33, 37, 38, 39];
            //
            //        SanitaireMaps.CROSSWALK_TILES = [8, 9, 10, 11];
            //
            //        0 = road
            //        1 = building
            //        2 = intersection


            /*
            5x5 tiles
            */
            var Blocks = {};
//            "SOLID"
//            "VERTICAL"
//            "HORIZONTAL"
//            "PLUS"
//            "T_LEFT"
//            "T_RIGHT"
//            "T_UP"
//            "T_DOWN"
//            "UP_LEFT"
//            "UP_RIGHT"
//            "DOWN_RIGHT"
//            "DOWN_LEFT"
//             
//            var Blocks = {
//                SOLID :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                VERTICAL :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                HORIZONTAL :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                PLUS :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                T_LEFT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                T_RIGHT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                T_UP :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                T_DOWN :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                UP_LEFT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                UP_RIGHT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 0, 0],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                DOWN_RIGHT :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                DOWN_LEFT :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [0, 0, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ]
//
//            };
            var prettyPrint = function(block){
                var print = '';
                for (var i = 0; i<block.length; i++){
                    for (var j = 0; j<block[0].length; j++){
                        var next = block[i][j].toString();
                        while (next.length<4){
                            next = next.concat(" ");
                        }
                        print = print.concat(next);
                    }
                    print = print.concat("\n");
                }
                console.log(print);
            };



            var blockMaker = function (rowSize, colSize, up, right, down, left){


                var block = [];
                for (var i=0; i<rowSize; i++){
                    block.push([]);
                    for (var j = 0; j<colSize; j++){
                        block[i].push(IMPASSABLE);
                    }
                }
                var rowNum = Math.floor((rowSize-1)/2);
                var colNum = Math.floor((colSize-1)/2);

                if (up){
                    for (var i = 0; i<rowNum+1; i++){
                        block[i][colNum] = VER_ROAD;
                    }
                }
                if (down){
                    for (var i = rowNum; i<rowSize; i++){
                        block[i][colNum] = VER_ROAD;
                    }
                }
                if (left){
                    for (var i = 0; i<colNum+1; i++){
                        block[rowNum][i] = HOR_ROAD;
                    }
                }
                if (right){
                    for (var i = colNum; i<colSize; i++){
                        block[rowNum][i] = HOR_ROAD;
                    }
                }
                return block;
            };

            var BlockTypesMaker = function(rowSize, colSize){
                // up, right, down, left
                Blocks.SOLID = blockMaker(rowSize,colSize,false, false, false, false);

                Blocks.VERTICAL = blockMaker(rowSize,colSize,true, false, true, false);
                Blocks.HORIZONTAL = blockMaker(rowSize,colSize,false, true, false, true);

                Blocks.T_UP = blockMaker(rowSize,colSize,true, true, false, true);
                Blocks.T_RIGHT = blockMaker(rowSize,colSize,true, true, true, false);
                Blocks.T_DOWN = blockMaker(rowSize,colSize,false, true, true, true);
                Blocks.T_LEFT = blockMaker(rowSize,colSize,true, false, true, true);

                Blocks.UP_LEFT = blockMaker(rowSize,colSize,true, false, false, true);
                Blocks.UP_RIGHT = blockMaker(rowSize,colSize,true, true, false, false);
                Blocks.DOWN_LEFT = blockMaker(rowSize,colSize,false, false, true, true);
                Blocks.DOWN_RIGHT = blockMaker(rowSize,colSize,false, true, true, false);
                Blocks.PLUS = blockMaker(rowSize,colSize,true, true, true, true);

            };

            // weights do no have to add to 1, the will be normalized in all cases
            var PathToRight = {
                YES: {
                    "SOLID":0,
                    "HORIZONTAL":1,
                    "PLUS":.25,
                    "T_LEFT":1,
                    "T_UP":1,
                    "T_DOWN":1,
                    "UP_LEFT":1,
                    "DOWN_LEFT":1
                },
                NO: {
                    "SOLID":.5,
                    "VERTICAL":1,
                    "T_RIGHT":1,
                    "UP_RIGHT":1,
                    "DOWN_RIGHT":1
                }
            }

            var PathDown = {
                YES: {
                    "SOLID":0,
                    "VERTICAL":1,
                    "PLUS":.25,
                    "T_LEFT":1,
                    "T_RIGHT":1,
                    "T_UP":1,
                    "UP_LEFT":1,
                    "UP_RIGHT":1
                },
                NO: {
                    "SOLID":.5,
                    "HORIZONTAL":1,
                    "T_DOWN":1,
                    "DOWN_RIGHT":1,
                    "DOWN_LEFT":1
                }
            }

            var BlockSuccessors = {
                "SOLID": {
                    right: PathToRight.NO,
                    down: PathDown.NO
                },
                "VERTICAL":{
                    right: PathToRight.NO,
                    down: PathDown.YES
                },
                "HORIZONTAL":{
                    right: PathToRight.YES,
                    down: PathDown.NO
                },
                "PLUS":{
                    right: PathToRight.YES,
                    down: PathDown.YES
                },
                "T_LEFT":{
                    right: PathToRight.NO,
                    down: PathDown.YES
                },
                "T_RIGHT":{
                    right: PathToRight.YES,
                    down:PathDown.YES
                },
                "T_UP":{
                    right: PathToRight.YES,
                    down: PathDown.NO
                },
                "T_DOWN":{
                    right: PathToRight.YES,
                    down: PathDown.YES
                },
                "UP_LEFT":{
                    right: PathToRight.NO,
                    down: PathDown.NO
                },
                "UP_RIGHT":{
                    right: PathToRight.YES,
                    down:PathDown.NO
                },
                "DOWN_RIGHT":{
                    right: PathToRight.YES,
                    down: PathDown.YES
                },
                "DOWN_LEFT":{
                    right: PathToRight.NO,
                    down: PathDown.YES
                }
            };

            /*
             Generates a conceptual map based on descriptions of crossings.
             For example,

                |_|

                11011 11111 11011
                11011 11111 11011
                11000 00000 00011
                11111 11111 11111
                11111 11111 11111

             would be:
                [["UP_RIGHT", "HORIZONTAL", "UP_LEFT"]
             */
            var mapDescriptionGenerate = function(mapRows, mapCols){
                // 50x50 is 10x10 blocks

                // If at (row, col) = (0, 0), pretend that up and left are SOLID
                // If row = 0, pretend up is SOLID
                // If col = 0, pretend left is SOLID
                var map = [];
                for (var row = 0; row < mapRows; row++){
                    map.push([])
                    var up; // these are strings eg, "SOLID"
                    var left;
                    for (var col = 0; col< mapCols; col++){
                        if (row  == 0){
                            if (col ==0){ // if (i, j) = (0, 0)
                                up = "SOLID";
                                left = "SOLID";
                            } else {
                                up = "SOLID";
                                left = map[row][col-1];
                            }
                        }
                        else if (col == 0){ // will not have the case (i, j) = (0, 0)
                            up = map[row-1][col];
                            left = "SOLID";
                        } else { // all other cases
                            up = map[row-1][col];
                            left = map[row][col-1];
                        }
                        // find intersection
                        var possibilitiesFromUp = BlockSuccessors[up].down;
                        var possibilitiesFromUpKeys = Object.keys(possibilitiesFromUp);
                        var possibilitiesFromLeft = BlockSuccessors[left].right;
                        var possibilities = {};
                        var sumProbabilities = 0;

                        // edge cases
                        var edgeCase = false;
                        if (row == mapRows -1){
                            edgeCase = true;
                            if (col == mapCols - 1){ // bottom right cell
                                var allowed = {
                                    "SOLID":1,
                                    "UP_LEFT":1
                                }
                            } else { // bottom row
                                var allowed = {
                                    "SOLID":1,
                                    "HORIZONTAL":1,
                                    "T_UP": 1,
                                    "UP_RIGHT":1,
                                    "UP_LEFT":1
                                }
                            }
                        } else if (col == mapCols -1){ // rightmost Column
                            edgeCase = true;
                            var allowed = {
                                "SOLID":1,
                                "VERTICAL":1,
                                "T_LEFT":1,
                                "UP_LEFT":1,
                                "DOWN_LEFT":1
                            }
                        }
                        if (edgeCase){
                            var allowedKeys = Object.keys(allowed);
                            for (var i = 0; i<allowedKeys.length; i++){
                                var key = allowedKeys[i];
                                if ((key in possibilitiesFromLeft)&&(key in possibilitiesFromUp)) {
                                    var probability = allowed[key] * possibilitiesFromLeft[key] * possibilitiesFromUp[key];
                                    sumProbabilities += probability;
                                    possibilities[key] = probability;
                                }
                            }
                        } else {
                            for (var i = 0; i<possibilitiesFromUpKeys.length; i++){
                                var key = possibilitiesFromUpKeys[i];
                                if (key in possibilitiesFromLeft){
                                    var probability = possibilitiesFromLeft[key]*possibilitiesFromUp[key];
                                    sumProbabilities += probability;
                                    possibilities[key] = probability;
                                }
                            }
                        }
                        var possibilitiesKeys = Object.keys(possibilities);
                        var possibilitiesProbRanges = [];
                        var probRange = 0;
                        for (var i = 0; i<possibilitiesKeys.length; i++){
                            var key = possibilitiesKeys[i];
                            var newProb = possibilities[key]/sumProbabilities;
                            possibilities[key] = newProb; // don't actually need to do this
                            probRange += newProb;
                            possibilitiesProbRanges.push(probRange);
                        }

                        // get random number
                        var rand = Math.random();
                        var index;
                        for (var i = 0; i<possibilitiesKeys.length; i++){
                            if (rand<possibilitiesProbRanges[i]){
                                index = i;
                                break;
                            }
                        }
                        var newBlock = possibilitiesKeys[index];
                        if (!newBlock){
                            newBlock = "SOLID"; // sometimes happens for the last cell
                        }
                        map[row].push(newBlock);
                    }
                }
                return map
            };

            var emptyMapDescriptionGenerate = function(mapRows, mapCols) {
                var map = [];
                for (var row = 0; row < mapRows; row++) {
                    map.push([])
                    for (var col = 0; col < mapCols; col++) {
                        map[row].push("SOLID");
                    }
                }
                return map;
            };

            var emptyMapGenerate = function(numRows, numCols){
                return mapDecode(emptyMapDescriptionGenerate(numRows, numCols));
            }

            /*
                Decodes a mapdescription to produce an array of 0-1 which represents the map
             */
            var mapDecode = function(mapDescription){
                var data = [];
                for (var rowNum = 0; rowNum<mapDescription.length; rowNum++){
                    for (var blockRowNum = 0; blockRowNum<blockHeight; blockRowNum++){
                        var rowData = [];
                        for (var colNum = 0; colNum<mapDescription[rowNum].length; colNum++){
                            var description = mapDescription[rowNum][colNum];
                            var descriptionArray = Blocks[description];
                            rowData = rowData.concat(descriptionArray[blockRowNum]);
                        }
                        data.push(rowData);
                    };
                }
                return data;
            };

            /*
                Generates a random numRows*numCols map
             */
            var mapGenerate = function(numRows, numCols){
                var mapEmpty = true;
                while (mapEmpty){
                    var map = mapDecode(mapDescriptionGenerate(numRows, numCols));
                    if ((map.length === Blocks.SOLID.length)&&(map[0].length === Blocks.SOLID.length)){ // for the 5x5 map that will always be empty
                        break;
                    }
                    for (var i = 0; i<map.length; i++){
                        for (var j = 0; j<map[0].length; j++){
                            if (STRAIGHT_ROADS.has(map[i][j])){
                                mapEmpty = false;
                            }
                        }
                    }
                }

                combineDisconnected(map);
                markIntersections(map, false);
                return map;
            }

            /** http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
             * Randomize array element order in-place.
             * Using Durstenfeld shuffle algorithm.
             */
            function shuffleArray(array) {
                for (var i = array.length - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    var temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
                return array;
            }

            // mutates
            var combineDisconnected = function(map){
                var components = findComponents(map, TileType.PASSABLE);
                if (components.length>1){
                    shuffleArray(components);
                    for (var compNum = 0; compNum < components.length-1; compNum++){
                        var first = components[compNum];
                        var second = components[compNum+1];
                        // select a point in 1st and 2nd component
                        // join them
                        var point1 = first[Math.floor(first.length/2)];
                        var point2 = second[Math.floor(second.length/2)];
                        var x1 = point1[1];
                        var y1 = point1[0];
                        var x2 = point2[1];
                        var y2 = point2[0];

                        var center = findBlockCenter(map, y1, x1);
                        if (center.length === 0){
                            console.log("point1", y1, x1, center);
                        }
                        x1 = center[1];
                        y1 = center[0];
                        center = findBlockCenter(map, y2, x2);
                        if (center.length === 0){
                            console.log("point2",y2, x2, center);
                        }

                        x2 = center[1];
                        y2 = center[0];

                        var x_start;
                        var x_end;
                        var y_start;
                        var y_end;
                        var x_hold;
                        var y_hold;
                        if (x1<x2){
                            x_start = x1;
                            x_end = x2;
                        } else {
                            x_start = x2;
                            x_end = x1;
                        }
                        if (y1<y2){
                            y_start = y1;
                            y_end = y2;
                        } else {
                            y_start = y2;
                            y_end = y1;
                        }

                        if ((x1<x2 && y1<y2) || (x2<x1 && y2<y1)){ //low high
                            x_hold = x_start;
                            y_hold = y_end;
                        } else{ //low low
                            x_hold = x_start;
                            y_hold = y_start;
                        }


                        for (var i = x_start; i<x_end+1; i++){
                            if (map[y_hold][i] === IMPASSABLE){
                                map[y_hold][i] = HOR_ROAD; // use 5 for debugging
                            }
                        }

                        for (var j = y_start; j<y_end+1; j++){
                            if (map[j][x_hold] === IMPASSABLE){
                                map[j][x_hold] = VER_ROAD; // use 5 for debugging
                            }
                        }
                    }
                }

            };

            // only to be used on unpadded graphs
            var findBlockCenter = function(map, row, col){
                if (row>map.length-1 || row<0){
                    return [];
                }
                if (col>map[0].length-1 || col<0){
                    return [];
                }
                var blockHeight = Blocks.SOLID.length;
                var blockWidth = Blocks.SOLID[0].length;
                var row_start = row - Math.floor((blockHeight-1)/2);
                var col_start = col - Math.floor((blockWidth-1)/2);
                var row_end = row + Math.ceil((blockHeight-1)/2);
                var col_end = col + Math.ceil((blockWidth-1)/2);
                if (row_start<0){
                    row_start = 0;
                }
                if (row_end>map.length-1){
                    row_end = map.length-1;
                }
                if (col_start<0){
                    col_start = 0;
                }
                if (col_end>map[0].length-1){
                    col_end = map[0].length-1;
                }
                for (var i = row_start; i<row_end+1; i++){
                    for (var j = col_start; j<col_end+1; j++){
                        if ((i%blockHeight)=== Math.floor((blockHeight-1)/2) &&
                                (j%blockWidth)=== Math.floor((blockWidth-1)/2)){ //if i and j are in the middle of the block
                            if (TileType.PASSABLE.has(map[i][j])){
                                return [i,j]
                            }
                        }
                    }
                }
                return [];
            };

            //
            var addPadding = function(map, numTilesRow, numTilesCol){
                // to offset the effects of even blocks size, the padding adds
                // extra empty tiles to the top and left :)
                var paddedMap = [];
                var paddingTop = Math.ceil((numTilesRow - map.length)/2);
                var paddingBottom = Math.floor((numTilesRow - map.length)/2);
                var paddingLeft = Math.ceil((numTilesCol - map[0].length)/2);
                var paddingRight = Math.floor((numTilesCol - map[0].length)/2);

                // add top padding
                for (var i = 0; i<paddingTop; i++){
                    paddedMap.push([]);
                    for (var j=0; j<numTilesCol; j++){
                        paddedMap[i].push(IMPASSABLE);
                    }
                }

                // add left and right paddings
                for (var i = paddingTop; i<paddingTop+map.length; i++){
                    paddedMap.push([]);
                    // left padding
                    for (j=0; j<paddingLeft; j++){
                        paddedMap[i].push(IMPASSABLE);
                    }

                    // middle portion
                    paddedMap[i] = paddedMap[i].concat(map[i]);

                    // right padding
                    for (j=paddingLeft+map[0].length; j<numTilesCol; j++){
                        paddedMap[i].push(IMPASSABLE);
                    }
                }

                // bottom padding
                for (var i = paddingTop+map.length; i<numTilesRow; i++){
                    paddedMap.push([]);
                    for (var j=0; j<numTilesCol; j++){
                        paddedMap[i].push(IMPASSABLE);
                    }
                }

                return paddedMap;
            };


            // i = row; j = col
            var checkIntersection = function(map, i, j){
                if (!map[i] || !map[i][j]){
                    return [false, IMPASSABLE];
                }

                var up    = 2;
                var down  = 3;
                var left  = 5;
                var right = 7;

                var tileType = TileType.PASSABLE;
                var ID = -1;

                if (tileType.has(map[i][j])){
                    if ((i>0) && tileType.has(map[i-1][j])) {//up
                        ID *= up;
                    }
                    if ((j>0) && tileType.has(map[i][j-1])){//left
                        ID *= left;
                    }
                    if ((j<map[0].length-1) && tileType.has(map[i][j+1])){//right
                        ID *= right;
                    }
                    if ((i<map.length-1) && tileType.has(map[i+1][j])){//down
                        ID *= down;
                    }
                }
                if ((ID != -1) && (ID in INTERSECTIONS)){
                    return [true, ID];  // ID is new map value
                }
                return [false, map[i][j]]; // just return the old value
            };





            var checkIntersectionOfSurroundings = function(map, i, j){
                var own = checkIntersection(map, i, j);
                var up = checkIntersection(map, i-1, j);
                var down = checkIntersection(map, i+1, j);
                var left = checkIntersection(map, i, j-1);
                var right = checkIntersection(map, i, j+1);

                return [own, up, down, left, right];
            };



            // mutates
            var defineTileDirection = function(map, i, j){ // to be preceeded/followed by checking for intersections
                                                            // ie, (i,j) should not be an intersection

                if (!map[i] || !map[i][j]){
                    return;
                }

                var tileType = TileType.PASSABLE;

                // in case the tile direction is undefined
                // horizontals will stay horizontal and verticals will stay vertical
                // however, incorrect labels will be fixed
                if (ROADS.has(map[i][j])){
                    map[i][j] = HOR_ROAD; // initially define it as horizontal

                    // if it has a vertical component, define it as vertical
                    if ((i>0) && tileType.has(map[i-1][j])) {//up
                        map[i][j] = VER_ROAD;
                    }
                    if ((i<map.length-1) && tileType.has(map[i+1][j])){//down
                        map[i][j] = VER_ROAD;
                    }
                }
            };

            // removes unknown roads
            // mutates
            var defineTileDirectionOfSurroundings = function(map, i, j){
                defineTileDirection(map, i, j);
                defineTileDirection(map, i-1, j);
                defineTileDirection(map, i+1, j);
                defineTileDirection(map, i, j-1);
                defineTileDirection(map, i, j+1);

            };


            var checkForStop = function(map, i, j) {
                if (TileType.PASSABLE.has(map[i][j])) {
                    if ((i > 0) && (map[i - 1][j] in INTERSECTIONS )) {//up
                        return [true, VER_STOP];
                    }
                    if ((j > 0) && (map[i][j - 1] in INTERSECTIONS )) {//left
                        return [true, HOR_STOP];
                    }
                    if ((j < map[0].length - 1) && (map[i][j+1] in INTERSECTIONS)) {//right
                        return [true, HOR_STOP];
                    }
                    if ((i < map.length - 1) && (map[i+1][j] in INTERSECTIONS)) {//down
                        return [true, VER_STOP];
                    }
                }
                return [false, null];
            }

            // mutates
            // these are the tiles that the player stops at
            // looks at the tiles around (i,j)
            var markOrRemoveIntersectionStopTiles = function(map, i, j, mark, updateMap){
                if (!map[i] || !map[i][j]){
                    return;
                }

                if (map[i][j] in INTERSECTIONS){ // it is an intersection
                    if (!mark) { // we are removing this, so might as well unmark it here
                        map[i][j] = UNKNOWN_ROAD; // since only removing roads does this, it's going to be fixed later
                        var [isStop, type] = checkForStop(map, i, j);
                        if (isStop) { // it is actually a stop for some other intersection
                            if (type === HOR_STOP) {
                                if (updateMap) {
                                    $("[data-row='" + (i) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("horStop");
                                }
                                map[i][j] = HOR_STOP;
                            } else {
                                if (updateMap) {
                                    $("[data-row='" + (i) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("verStop");
                                }
                                map[i][j] = VER_STOP;

                            }
                        } else {
                            if (updateMap) {
                                $("[data-row='" + (i) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("black");
                            }
                        }
                    }
                    if ((i>0) && ROADS.has(map[i-1][j])) {//up
                        if (mark){
                            if(updateMap) {
                                $("[data-row='" + (i - 1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("verStop");
                            }
                            map[i-1][j] = VER_STOP;
                        } else {
                            var [isStop, type] = checkForStop(map, i-1, j);
                            if (isStop){ // it is actually a stop for some other intersection
                                if (type === HOR_STOP){
                                    if (updateMap){
                                        $("[data-row='" + (i - 1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("horStop");
                                    }
                                    map[i-1][j] = HOR_STOP;
                                } else {
                                    if (updateMap){
                                        $("[data-row='" + (i - 1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("verStop");
                                    }
                                    map[i-1][j] = VER_STOP;

                                }
                            } else {
                                if(updateMap) {
                                    $("[data-row='" + (i - 1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("black");
                                }
                                map[i-1][j] = VER_ROAD;
                            }

                        }

                    }
                    if ((j>0) && ROADS.has(map[i][j-1])){//left
                        if (mark){
                            if(updateMap) {
                                $("[data-row='" + (i) + "'][data-col='" + (j - 1) + "']").removeClass().addClass("cell").addClass("horStop");
                            }
                            map[i][j-1] = HOR_STOP;
                        } else{
                            var [isStop, type] = checkForStop(map, i, j-1);
                            if (isStop){ // it is actually a stop for some other intersection
                                if (type === HOR_STOP){
                                    if (updateMap){
                                        $("[data-row='" + (i) + "'][data-col='" + (j-1) + "']").removeClass().addClass("cell").addClass("horStop");
                                    }
                                    map[i][j-1] = HOR_STOP;
                                } else {
                                    if (updateMap){
                                        $("[data-row='" + (i) + "'][data-col='" + (j-1) + "']").removeClass().addClass("cell").addClass("verStop");
                                    }
                                    map[i][j-1] = VER_STOP;

                                }
                            } else {
                                if(updateMap) {
                                    $("[data-row='" + (i) + "'][data-col='" + (j-1) + "']").removeClass().addClass("cell").addClass("black");
                                }
                                map[i][j-1] = VER_ROAD;
                            }
                        }

                    }
                    if ((j<map[0].length-1) && ROADS.has(map[i][j+1])){//right
                        if (mark){
                            if(updateMap) {
                                $("[data-row='" + (i) + "'][data-col='" + (j + 1) + "']").removeClass().addClass("cell").addClass("horStop");
                            }
                            map[i][j+1] = HOR_STOP;
                        } else {
                            var [isStop, type] = checkForStop(map, i, j+1);
                            if (isStop){ // it is actually a stop for some other intersection
                                if (type === HOR_STOP){
                                    if (updateMap){
                                        $("[data-row='" + (i) + "'][data-col='" + (j+1) + "']").removeClass().addClass("cell").addClass("horStop");
                                    }
                                    map[i][j+1] = HOR_STOP;
                                } else {
                                    if (updateMap){
                                        $("[data-row='" + (i) + "'][data-col='" + (j+1) + "']").removeClass().addClass("cell").addClass("verStop");
                                    }
                                    map[i][j+1] = VER_STOP;

                                }
                            } else {
                                if(updateMap) {
                                    $("[data-row='" + (i) + "'][data-col='" + (j+1) + "']").removeClass().addClass("cell").addClass("black");
                                }
                                map[i][j+1] = VER_ROAD;
                            }
                        }

                    }
                    if ((i<map.length-1) && ROADS.has(map[i+1][j])){//down
                        if (mark){
                            if(updateMap) {
                                $("[data-row='" + (i + 1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("verStop");
                            }
                            map[i+1][j] = VER_STOP;

                        } else {
                            var [isStop, type] = checkForStop(map, i+1, j);
                            if (isStop){ // it is actually a stop for some other intersection
                                if (type === HOR_STOP){
                                    if (updateMap){
                                        $("[data-row='" + (i+1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("horStop");
                                    }
                                    map[i+1][j] = HOR_STOP;
                                } else {
                                    if (updateMap){
                                        $("[data-row='" + (i+1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("verStop");
                                    }
                                    map[i+1][j] = VER_STOP;

                                }
                            } else {
                                if(updateMap) {
                                    $("[data-row='" + (i+1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("black");
                                }
                                map[i+1][j] = VER_ROAD;
                            }
                        }
                    }
                }
            };


            // mutates
            var markIntersections = function(map, display){

                for (var i = 0; i< map.length; i++){ // i is y is row
                    for (var j = 0; j<map[0].length; j++){ // j is x is col
                        var [isIntersection, intersectionID] = checkIntersection(map, i, j);
                        if(isIntersection){
                            map[i][j] = intersectionID;
                            markOrRemoveIntersectionStopTiles(map, i, j, true, display);
                        }
                    }
                }
            };


        </script>
    </div>

    <div id="displayMap">
        <script>
            /*
                displays the map as a canvas element inside #mapboard
            */
            var displayMap = function(map){

                $("#mapboard").html("");
                var width = map[0].length;         // width in pixels
                var height = map.length;


                var makeCell = function(color, row, col){
                    return "<div class='"+color+" cell' data-row='"+row+"' data-col='"+col+"' style='height:"+cellSize+"px;width:"+cellSize+"px;'></div>";

                }
                var mapDrawing = "<div id='mapContainer'>";
                for (var j=0; j<width; j++){
                    mapDrawing = mapDrawing.concat("<div class='col'>");
                    for (var i=0; i<height; i++){
                        mapDrawing = mapDrawing.concat("<div class='row'>");
                        if (TileType.PASSABLE.has(map[i][j])){
                            if(map[i][j] === DEBUGGING){ //debugging
                                mapDrawing = mapDrawing.concat(makeCell("white",i,j));
                            } else if (map[i][j] in INTERSECTIONS) { // intersection
                                mapDrawing = mapDrawing.concat(makeCell("intersection", i, j));
                            } else if (STOPS.has(map[i][j])){ // stop
                                if (map[i][j] === HOR_STOP){
                                    mapDrawing = mapDrawing.concat(makeCell("horStop",i,j));
                                } else {
                                    mapDrawing = mapDrawing.concat(makeCell("verStop",i,j));
                                }

                            } else {
                                mapDrawing = mapDrawing.concat(makeCell("black",i,j));
                            }
                        } else {
                            mapDrawing = mapDrawing.concat(makeCell("grey",i,j));
                        }
                        mapDrawing = mapDrawing.concat("</div>");
                    }
                    mapDrawing = mapDrawing.concat("</div>");
                }
                mapDrawing = mapDrawing.concat("</div>");
                $("#mapboard").html(mapDrawing);
            }
            
        </script>
    </div>
    <div id="manualMapEdit">
        <script type="text/javascript">
            $(function(){
                $('#start-edit').click(function(){
                    $('#edit-buttons-show-hide').css({
                        display: 'none'
                    });
                    $('#edit-button').css({
                        display: 'block'
                    });
                })

                var editingAdd = false;
                var editingRemove = false;


                var dragging = false;

                $("#reset").prop("disabled",true);

                $("#add").click(function(){
                    editingAdd = true;
                    editingRemove = false;
                    $("#add").prop("disabled",true);
                    $("#remove").prop("disabled",false);
                    $("#reset").prop("disabled",false);
                });
                $("#remove").click(function(){
                    editingAdd = false;
                    editingRemove = true;
                    $("#add").prop("disabled",false);
                    $("#remove").prop("disabled",true);
                    $("#reset").prop("disabled",false);
                });

                $("#reset").click(function(){
                    editingAdd = false;
                    editingRemove = false;
                    $("#add").prop("disabled",false);
                    $("#remove").prop("disabled",false);
                    $("#reset").prop("disabled",true);
                    currentMap = $.extend(true, [], currentMapSafetyCopy);
                    displayMap(currentMap);
                });

                $("#done").click(function(){
                    editingAdd = false;
                    editingRemove = false;
                    $("#add").prop("disabled",false);
                    $("#remove").prop("disabled",false);
                    $("#reset").prop("disabled",true);
//                    markIntersections(currentMap, true);
                    currentMapSafetyCopy = $.extend(true, [], currentMap);

                    // hide away edit options
                    $('#edit-buttons-show-hide').css({
                        display: 'block'
                    });
                    $('#edit-button').css({
                        display: 'none'
                    });
                });

                $("body").on("mousedown","#mapContainer", function(evt){
                    evt.preventDefault();
                    if (editingAdd || editingRemove){
                        dragging = true;
                    }
                });

                $("body").on("mouseup","#mapContainer", function(evt){
                    evt.preventDefault();
                    dragging = false;
                });

                $("body").on("mousemove ",".cell", function(evt) {
                    evt.preventDefault();

                    var row = $(this).data("row");
                    var col = $(this).data("col");
                    if (dragging) {
                        if (editingAdd) {
                            $(this).removeClass();
                            $(this).addClass("cell").addClass("black");
                            currentMap[row][col] = UNKNOWN_ROAD;
                            // When a new road is drawn, at first we can't tell if it is horizontal or vertical
                            // We initially mark it as horizontal and then
                            // we check the surroundings to figure it out
                            // figure out = if a tile is unlabelled, see its surroundings to see which one it should be
                            //              if it is a intersection, that will be fixed later
                            //              we also look at the surrounding tiles to make sure to correct it if it was
                            //              previously mislabelled (the initial horizontal labelling)
                            // Note that unless a tile is stranded (in which case it is okay for it to be a horizontal tile)
                            // it will always have another tile next to it. If that is a new tile, the check will fix it; otherwise
                            // there will not be an issue to begin with
                            //

                            defineTileDirectionOfSurroundings(currentMap, row, col);
                            var newIntersections = checkIntersectionOfSurroundings(currentMap, row, col);
                            if (newIntersections[0][0]){ // own
                                $(this).removeClass();
                                $(this).addClass("cell").addClass("intersection");
                                currentMap[row][col] = newIntersections[0][1];
                                markOrRemoveIntersectionStopTiles(currentMap, row, col, true, true);
                            }
                            if (newIntersections[1][0]){ //up
                                $("[data-row='"+(row-1)+"'][data-col='"+col+"']").removeClass();
                                $("[data-row='"+(row-1)+"'][data-col='"+col+"']").addClass("cell").addClass("intersection");
                                currentMap[row-1][col] = newIntersections[1][1];
                                markOrRemoveIntersectionStopTiles(currentMap, row-1, col, true, true);
                            }
                            if (newIntersections[2][0]){ //down
                                $("[data-row='"+(row+1)+"'][data-col='"+col+"']").removeClass();
                                $("[data-row='"+(row+1)+"'][data-col='"+col+"']").addClass("cell").addClass("intersection");
                                currentMap[row+1][col] = newIntersections[2][1];
                                markOrRemoveIntersectionStopTiles(currentMap, row+1, col, true, true);
                            }
                            if (newIntersections[3][0]){ //left
                                $("[data-row='"+row+"'][data-col='"+(col-1)+"']").removeClass();
                                $("[data-row='"+row+"'][data-col='"+(col-1)+"']").addClass("cell").addClass("intersection");
                                currentMap[row][col-1] = newIntersections[3][1];
                                markOrRemoveIntersectionStopTiles(currentMap, row, col-1, true, true);
                            }
                            if (newIntersections[4][0]){ //right
                                $("[data-row='"+row+"'][data-col='"+(col+1)+"']").removeClass();
                                $("[data-row='"+row+"'][data-col='"+(col+1)+"']").addClass("cell").addClass("intersection");
                                currentMap[row][col+1] = newIntersections[4][1];
                                markOrRemoveIntersectionStopTiles(currentMap, row, col+1, true, true);
                            }
                        } else if (editingRemove) {
                            if (currentMap[row][col] in INTERSECTIONS){
                                markOrRemoveIntersectionStopTiles(currentMap, row, col, false, true);
                            }
                            $(this).removeClass();
                            $(this).addClass("cell").addClass("grey");
                            currentMap[row][col] = IMPASSABLE; // get rid of current road

                            var newIntersections = checkIntersectionOfSurroundings(currentMap, row, col);
                            // if intersections need to be removed
                            if (!newIntersections[1][0] && currentMap[row-1] && (currentMap[row-1][col] in INTERSECTIONS)){ //up
                                $("[data-row='"+(row-1)+"'][data-col='"+col+"']").removeClass().addClass("cell").addClass("black");
                                markOrRemoveIntersectionStopTiles(currentMap, row-1, col, false, true);
                                currentMap[row-1][col] = UNKNOWN_ROAD;
                            }
                            if (!newIntersections[2][0] && currentMap[row+1][col] && (currentMap[row+1][col] in INTERSECTIONS)){ //down
                                $("[data-row='"+(row+1)+"'][data-col='"+col+"']").removeClass().addClass("cell").addClass("black");
                                markOrRemoveIntersectionStopTiles(currentMap, row+1, col, false, true);
                                currentMap[row+1][col] = UNKNOWN_ROAD;
                            }
                            if (!newIntersections[3][0] && (currentMap[row][col-1] in INTERSECTIONS)){ //left
                                $("[data-row='"+row+"'][data-col='"+(col-1)+"']").removeClass().addClass("cell").addClass("black");
                                markOrRemoveIntersectionStopTiles(currentMap, row, col-1, false, true);
                                currentMap[row][col-1] = UNKNOWN_ROAD;
                            }
                            if (!newIntersections[4][0] && (currentMap[row][col+1] in INTERSECTIONS)){ //right
                                $("[data-row='"+row+"'][data-col='"+(col+1)+"']").removeClass().addClass("cell").addClass("black");
                                markOrRemoveIntersectionStopTiles(currentMap, row, col+1, false, true);
                                currentMap[row][col+1] = UNKNOWN_ROAD;
                            }
                            defineTileDirectionOfSurroundings(currentMap, row, col);
                        }
                    }

                });
            });








        </script>
    </div>
    <div id="dat.gui">
        <script type="text/javascript">
            /*
                height, width integer
             */
            var createNewMap = function(height, width){
//                var mapHeight =
                var map = mapGenerate(height,width);
                unpaddedMap = map;
                currentMap = addPadding(map, numTilesRow, numTilesCol);
                displayMap(currentMap);
            };

            var saveMap = function(map){
                var csvContent = "data:text/csv;charset=utf-8,";
                map.forEach(function(infoArray, index){
                    dataString = infoArray.join(",");
                    csvContent += index < map.length ? dataString+ "\n" : dataString;

                });


                var encodedUri = encodeURI(csvContent);
                var link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                var name = this.mapNameToSave;
                if (!name){
                    var millis = new Date();
                    var filename = "cs_map_" + millis.getTime() + ".csv";
                } else {
                    var filename = name + ".csv";
                }

                link.setAttribute("download", filename);

                link.click(); // This will download the data file named "{file name}.csv".
            }



            var mapTweeker = function() {
                this.mapNameToSave = "newMap";
                this.mapNameToLoad = "test12";
                this.cellSize = cellSize;

                this.numTilesCol = numTilesCol;
                this.numTilesRow = numTilesRow;
                this.blockWidth = blockWidth;
                this.blockHeight = blockHeight;
                this.density = 0;
                this.deadends = false;
                this.resizeCurrent = function(){
                    cellSize = this.cellSize;
                    displayMap(currentMap);
                };
                
                this.IMPASSABLE = IMPASSABLE;
                this.VERTICAL = VER_ROAD;
                this.HORIZONTAL = HOR_ROAD;
                this.HOR_STOP = HOR_STOP;
                this.VER_STOP = VER_STOP;
                this.PLUS = INTERSECTION1["PLUS"];
                this.T_LEFT = INTERSECTION1["T_LEFT"];
                this.T_RIGHT = INTERSECTION1["T_RIGHT"];
                this.T_UP = INTERSECTION1["T_UP"];
                this.T_DOWN = INTERSECTION1["T_DOWN"];
                this.UP_LEFT = INTERSECTION1["UP_LEFT"];
                this.UP_RIGHT = INTERSECTION1["UP_RIGHT"];
                this.DOWN_RIGHT = INTERSECTION1["DOWN_RIGHT"];
                this.DOWN_LEFT = INTERSECTION1["DOWN_LEFT"];
                this.resetToDefault = function(){
                    this.IMPASSABLE = IMPASSABLE;
                    this.VERTICAL = VER_ROAD;
                    this.HORIZONTAL = HOR_ROAD;
                    this.HOR_STOP = HOR_STOP;
                    this.VER_STOP = VER_STOP;
                    this.PLUS = INTERSECTION1["PLUS"];
                    this.T_LEFT = INTERSECTION1["T_LEFT"];
                    this.T_RIGHT = INTERSECTION1["T_RIGHT"];
                    this.T_UP = INTERSECTION1["T_UP"];
                    this.T_DOWN = INTERSECTION1["T_DOWN"];
                    this.UP_LEFT = INTERSECTION1["UP_LEFT"];
                    this.UP_RIGHT = INTERSECTION1["UP_RIGHT"];
                    this.DOWN_RIGHT = INTERSECTION1["DOWN_RIGHT"];
                    this.DOWN_LEFT = INTERSECTION1["DOWN_LEFT"];

                }

                this.saveWithDefinedMapping = function(){
//                    markIntersections(currentMap, true);
                    var newMap = [];
                    for (var i= 0; i<currentMap.length; i++){
                        newMap.push([]);
                        for (var j=0; j<currentMap[0].length; j++){
                            switch(currentMap[i][j]){
                                case IMPASSABLE:
                                    newMap[i][j] = this.IMPASSABLE;
                                    break;
                                case VER_ROAD:
                                    newMap[i][j] = this.VERTICAL;
                                    break;
                                case HOR_ROAD:
                                    newMap[i][j] = this.HORIZONTAL;
                                    break;
                                case HOR_STOP:
                                    newMap[i][j] = this.HOR_STOP;
                                    break;
                                case VER_STOP:
                                    newMap[i][j] = this.VER_STOP;
                                    break;
                                case INTERSECTION1["PLUS"]:
                                    newMap[i][j] = this.PLUS;
                                    break;
                                case INTERSECTION1["T_LEFT"]:
                                    newMap[i][j] = this.T_LEFT;
                                    break;
                                case INTERSECTION1["T_RIGHT"]:
                                    newMap[i][j] = this.T_RIGHT;
                                    break;
                                case INTERSECTION1["T_UP"]:
                                    newMap[i][j] = this.T_UP;
                                    break;
                                case INTERSECTION1["T_DOWN"]:
                                    newMap[i][j] = this.T_DOWN;
                                    break;
                                case INTERSECTION1["UP_LEFT"]:
                                    newMap[i][j] = this.UP_LEFT;
                                    break;
                                case INTERSECTION1["UP_RIGHT"]:
                                    newMap[i][j] = this.UP_RIGHT;
                                    break;
                                case INTERSECTION1["DOWN_RIGHT"]:
                                    newMap[i][j] = this.DOWN_RIGHT;
                                    break;
                                case INTERSECTION1["DOWN_LEFT"]:
                                    newMap[i][j] = this.DOWN_LEFT;
                                    break;

                            }
                        }
                    }
                    saveMap(newMap);
                };
                
                this.update = function(){
                    density = this.density;
                    if (density === 0){
                        density = 1;
                    } else if (density<0){
                        density = 1/(-density);
                    } else {
                        density = density;
                    }
                    if (this.deadends){
                        PathDown.YES.SOLID = .5;
                        PathToRight.YES.SOLID = .5;
                    } else {
                        PathDown.YES.SOLID = 0;
                        PathToRight.YES.SOLID = 0;
                    }
                    PathDown.YES.VERTICAL = 1/density;
                    PathDown.NO.HORIZONTAL = 1/density;
                    PathToRight.YES.HORIZONTAL = 1/density;
                    PathToRight.NO.VERTICAL = 1/density;
                    PathDown.NO.SOLID = .5/density;
                    PathToRight.NO.SOLID = .5/density;
                    PathDown.YES.PLUS = .25*(density +1);
                    PathToRight.YES.PLUS = .25*(density+1);



                    numTilesCol = Math.round(this.numTilesCol);
                    numTilesRow = Math.round(this.numTilesRow);
                    blockHeight = Math.round(this.blockHeight);
                    blockWidth = Math.round(this.blockWidth);
                    BlockTypesMaker(blockHeight,blockWidth);
                    cellSize = this.cellSize;
                    numCols = Math.floor(this.numTilesCol/blockWidth);
                    numRows = Math.floor(this.numTilesRow/blockHeight)
                    createNewMap(numRows,numCols);
                    currentMapSafetyCopy  = $.extend(true, [], currentMap);
                };
                this.load = function(){
                    $("#mapboard").html("");
                    mapName = this.mapNameToLoad;
                    $.get(mapName + ".csv", function(data) {
                        var rows = data.split("\n");

                        var parsedMap = [];
                        for (var i = 0; i<rows.length-1; i++){
                            var cols = rows[i].split(",");
                            parsedMap.push(cols);
                            for (var j = 0; j<parsedMap[i].length;j++){
                                parsedMap[i][j] = parseInt(parsedMap[i][j]);
                            }
                        }

                        currentMap = parsedMap;
                        // display parsed map
                        displayMap(parsedMap);
                        currentMapSafetyCopy  = $.extend(true, [], currentMap);
                    });



                };

                this.loadEmptyMap = function(){
                    currentMap = emptyMapGenerate(numRows, numCols);
                    displayMap(currentMap);
                    currentMapSafetyCopy  = $.extend(true, [], currentMap);

                }
                this.saveWithDefaultMapping = function(){
//                    markIntersections(currentMap, true);
                    saveMap(currentMap);
                };
                
            };
        </script>
    </div>
    <div id="queryString">
        <script>
            var QueryString = function () {
                // This function is anonymous, is executed immediately and
                // the return value is assigned to QueryString!
                var query_string = {};
                var query = window.location.search.substring(1);
                var vars = query.split("&");
                for (var i=0;i<vars.length;i++) {
                    var pair = vars[i].split("=");
                    // If first entry with this name
                    if (typeof query_string[pair[0]] === "undefined") {
                        query_string[pair[0]] = decodeURIComponent(pair[1]);
                        // If second entry with this name
                    } else if (typeof query_string[pair[0]] === "string") {
                        var arr = [ query_string[pair[0]],decodeURIComponent(pair[1]) ];
                        query_string[pair[0]] = arr;
                        // If third or later entry with this name
                    } else {
                        query_string[pair[0]].push(decodeURIComponent(pair[1]));
                    }
                }
                return query_string;
            }();
        </script>
    </div>
    <script>
        window.onload = function() {
            var mapTweekerUI = new mapTweeker();
            var gui = new dat.GUI();


            var f1 = gui.addFolder("tweek");

            f1.add(mapTweekerUI, 'numTilesRow', 1, 100).step(1);
            f1.add(mapTweekerUI, 'numTilesCol', 1, 100).step(1);

            f1.add(mapTweekerUI, 'blockHeight', 1, 20).step(1);
            f1.add(mapTweekerUI, 'blockWidth', 1, 20).step(1);

            f1.add(mapTweekerUI, 'density', -10, 10).step(1);
            f1.add(mapTweekerUI, 'deadends');

            f1.add(mapTweekerUI, 'update');


            var f4 = gui.addFolder("defineTileMapping");
            f4.add(mapTweekerUI, "IMPASSABLE").listen();
            f4.add(mapTweekerUI, "VERTICAL").listen();
            f4.add(mapTweekerUI, "HORIZONTAL").listen();
            f4.add(mapTweekerUI, "VER_STOP").listen();
            f4.add(mapTweekerUI, "HOR_STOP").listen();
            f4.add(mapTweekerUI, "PLUS").listen();
            f4.add(mapTweekerUI, "T_LEFT").listen();
            f4.add(mapTweekerUI, "T_RIGHT").listen();
            f4.add(mapTweekerUI, "T_UP").listen();
            f4.add(mapTweekerUI, "T_DOWN").listen();
            f4.add(mapTweekerUI, "UP_LEFT").listen();
            f4.add(mapTweekerUI, "UP_RIGHT").listen();
            f4.add(mapTweekerUI, "DOWN_RIGHT").listen();
            f4.add(mapTweekerUI, "DOWN_LEFT").listen();
            f4.add(mapTweekerUI, "resetToDefault")

            var f3 = gui.addFolder("resizeDisplay");
            f3.add(mapTweekerUI, 'cellSize', 1, 20);
            f3.add(mapTweekerUI, 'resizeCurrent');

            var f5 = gui.addFolder("save");
            f5.add(mapTweekerUI, 'mapNameToSave');
            f5.add(mapTweekerUI, 'saveWithDefaultMapping');
            f5.add(mapTweekerUI, "saveWithDefinedMapping");

            var f2 = gui.addFolder("load");
            f2.add(mapTweekerUI, 'mapNameToLoad');
            f2.add(mapTweekerUI, 'load');
            f2.add(mapTweekerUI, 'loadEmptyMap');

            f1.closed = false;
            f3.closed = false;

            BlockTypesMaker(blockHeight,blockWidth);
            createNewMap(numRows, numCols);
            currentMapSafetyCopy  =$.extend(true, [], currentMap);

        };
    </script>
</div>
<div id="show-row-col">
    <script>
        $(function(){
            $('body').on('mouseenter', '.cell', function(event){
                var row = $(this).data("row");
                var col = $(this).data("col");
                var x= $(this).position().left;
                var y= $(this).position().top;
                $("#cell-row-col").html("("+row+","+col+")");
                $("#cell-row-col").css({
                    display: 'block',
                    position: 'absolute',
                    top: y-20,
                    left: x+20
                })
            });
            $('body').on('mouseleave', '#mapContainer', function(event){
                $("#cell-row-col").css({
                    display: 'none',
                })
            });
        });
    </script>
</div>
</body>
</html>