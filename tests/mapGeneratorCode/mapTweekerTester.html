<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CS Map Tweeker Tester</title>
  <link rel="stylesheet" type="text/css" href="mapboard.css">
</head>
<body>
<div id="edit">
    <div>Edit the map below (changes are automatically saved)
        <div id="edit-buttons-show-hide">
            <button id="start-edit" class="edit-btn">Edit</button>
        </div>
        <div id="edit-button">
            <button id="add" class="edit-btn">Add Roads</button>
            <button id="remove" class="edit-btn">Remove Roads</button>
            <button id="reset" class="edit-btn">Reset</button>
            <button id="done" class="edit-btn">Done</button>
        </div>
    </div>
</div>
<div id="cell-row-col"></div>
<div id="mapboard"></div>
<div id="scripts">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
    <script type="text/javascript" src="dat.gui.js"></script>
    <div id="globalVariables">
        <script>
            // Default values

            // For generating the map
            var numTilesCol = 40;
            var numTilesRow = 50;
            var blockWidth = 8;
            var blockHeight = 8;
            var numCols = Math.floor(numTilesCol/blockWidth);
            var numRows = Math.floor(numTilesRow/blockHeight);

            // for loading maps
            var mapName;

            // initial density of the map
            var density = 1;

            // the zoom factor for display
            var cellSize = 9;

            // map copies
            var currentMap; // the map shown, and actively edited
            var currentMapSafetyCopy; // a copy for the edited map
            var unpaddedMap; // a copy of the map without padding, useful for debugging

        </script>
    </div>
    <script type="text/javascript" src="graphAlgorithms.js"></script>
    <div id="mapGenerator">
        <script>
            /**
             * Created by Shinjini on 3/14/2016.
             */

            var Blocks = {};
            // Types:
//            "SOLID"
//            "VERTICAL"
//            "HORIZONTAL"
//            "PLUS"
//            "T_LEFT"
//            "T_RIGHT"
//            "T_UP"
//            "T_DOWN"
//            "UP_LEFT"
//            "UP_RIGHT"
//            "DOWN_RIGHT"
//            "DOWN_LEFT"
//             
//            var Blocks = {
//                SOLID :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                VERTICAL :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                HORIZONTAL :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                PLUS :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                T_LEFT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                T_RIGHT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                T_UP :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                T_DOWN :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [0, 0, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                UP_LEFT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [0, 0, 0, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                UP_RIGHT :
//                        [
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 0, 0],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1]
//                        ],
//
//                DOWN_RIGHT :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 0, 0, 0],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ],
//
//                DOWN_LEFT :
//                        [
//                            [1, 1, 1, 1, 1],
//                            [1, 1, 1, 1, 1],
//                            [0, 0, 0, 1, 1],
//                            [1, 1, 0, 1, 1],
//                            [1, 1, 0, 1, 1]
//                        ]
//
//            };

            /**
             * Prints maps or blocks in a row*col manner
             * @param Array of arrays
             */
            var prettyPrint = function(block){
                var print = '';
                for (var i = 0; i<block.length; i++){
                    for (var j = 0; j<block[0].length; j++){
                        var next = block[i][j].toString();
                        while (next.length<4){
                            next = next.concat(" ");
                        }
                        print = print.concat(next);
                    }
                    print = print.concat("\n");
                }
                console.log(print);
            };



            /**
             * Makes the blocks (described above)
             * @param rowSize {Number} number of tiles in a row
             * @param colSize {Number} number of tiles in a col
             * @param up {Boolean} whether there is a road up from the center of the block
             * @param right {Boolean}
             * @param down {Boolean}
             * @param left {Boolean}
             *
             * @returns block {Array of arrays} is a rowSize*colSize block described
             */
            var blockMaker = function (rowSize, colSize, up, right, down, left){
                var block = [];
                for (var i=0; i<rowSize; i++){
                    block.push([]);
                    for (var j = 0; j<colSize; j++){
                        block[i].push(IMPASSABLE);
                    }
                }
                var rowNum = Math.floor((rowSize-1)/2);
                var colNum = Math.floor((colSize-1)/2);

                if (up){
                    for (var i = 0; i<rowNum+1; i++){
                        block[i][colNum] = VER_ROAD;
                    }
                }
                if (down){
                    for (var i = rowNum; i<rowSize; i++){
                        block[i][colNum] = VER_ROAD;
                    }
                }
                if (left){
                    for (var i = 0; i<colNum+1; i++){
                        block[rowNum][i] = HOR_ROAD;
                    }
                }
                if (right){
                    for (var i = colNum; i<colSize; i++){
                        block[rowNum][i] = HOR_ROAD;
                    }
                }
                return block;
            };


            /**
             * Makes the all the different blocks (described above)
             * Mutates the global Blocks object
             * @param rowSize {Number} number of tiles in a row
             * @param colSize {Number} number of tiles in a col
             *
             */
            var BlockTypesMaker = function(rowSize, colSize){
                // up, right, down, left
                Blocks.SOLID = blockMaker(rowSize,colSize,false, false, false, false);

                Blocks.VERTICAL = blockMaker(rowSize,colSize,true, false, true, false);
                Blocks.HORIZONTAL = blockMaker(rowSize,colSize,false, true, false, true);

                Blocks.T_UP = blockMaker(rowSize,colSize,true, true, false, true);
                Blocks.T_RIGHT = blockMaker(rowSize,colSize,true, true, true, false);
                Blocks.T_DOWN = blockMaker(rowSize,colSize,false, true, true, true);
                Blocks.T_LEFT = blockMaker(rowSize,colSize,true, false, true, true);

                Blocks.UP_LEFT = blockMaker(rowSize,colSize,true, false, false, true);
                Blocks.UP_RIGHT = blockMaker(rowSize,colSize,true, true, false, false);
                Blocks.DOWN_LEFT = blockMaker(rowSize,colSize,false, false, true, true);
                Blocks.DOWN_RIGHT = blockMaker(rowSize,colSize,false, true, true, false);
                Blocks.PLUS = blockMaker(rowSize,colSize,true, true, true, true);

            };

            /**
             * Describes allowed tiles to the right, and their probability weights
             // weights do no have to add to 1, they will be normalized in all cases
             *
             */
            var PathToRight = {
                YES: {
                    "SOLID":0,
                    "HORIZONTAL":1,
                    "PLUS":.25,
                    "T_LEFT":1,
                    "T_UP":1,
                    "T_DOWN":1,
                    "UP_LEFT":1,
                    "DOWN_LEFT":1
                },
                NO: {
                    "SOLID":.5,
                    "VERTICAL":1,
                    "T_RIGHT":1,
                    "UP_RIGHT":1,
                    "DOWN_RIGHT":1
                }
            };

            /**
             * Describes allowed tiles to down, and their probability weights
             // weights do no have to add to 1, they will be normalized in all cases
             *
             */
            var PathDown = {
                YES: {
                    "SOLID":0,
                    "VERTICAL":1,
                    "PLUS":.25,
                    "T_LEFT":1,
                    "T_RIGHT":1,
                    "T_UP":1,
                    "UP_LEFT":1,
                    "UP_RIGHT":1
                },
                NO: {
                    "SOLID":.5,
                    "HORIZONTAL":1,
                    "T_DOWN":1,
                    "DOWN_RIGHT":1,
                    "DOWN_LEFT":1
                }
            };

            /**
             * Describes, for each tile type, allowed tiles to the right and down
             *
             */
            var BlockSuccessors = {
                "SOLID": {
                    right: PathToRight.NO,
                    down: PathDown.NO
                },
                "VERTICAL":{
                    right: PathToRight.NO,
                    down: PathDown.YES
                },
                "HORIZONTAL":{
                    right: PathToRight.YES,
                    down: PathDown.NO
                },
                "PLUS":{
                    right: PathToRight.YES,
                    down: PathDown.YES
                },
                "T_LEFT":{
                    right: PathToRight.NO,
                    down: PathDown.YES
                },
                "T_RIGHT":{
                    right: PathToRight.YES,
                    down:PathDown.YES
                },
                "T_UP":{
                    right: PathToRight.YES,
                    down: PathDown.NO
                },
                "T_DOWN":{
                    right: PathToRight.YES,
                    down: PathDown.YES
                },
                "UP_LEFT":{
                    right: PathToRight.NO,
                    down: PathDown.NO
                },
                "UP_RIGHT":{
                    right: PathToRight.YES,
                    down:PathDown.NO
                },
                "DOWN_RIGHT":{
                    right: PathToRight.YES,
                    down: PathDown.YES
                },
                "DOWN_LEFT":{
                    right: PathToRight.NO,
                    down: PathDown.YES
                }
            };

            /**
             Generates a conceptual map based on descriptions of crossings.
             For example,

                |_|

                11011 11111 11011
                11011 11111 11011
                11000 00000 00011
                11111 11111 11111
                11111 11111 11111

             would be:
                [["UP_RIGHT", "HORIZONTAL", "UP_LEFT"]]

             // Here 1 = not passable, 0 = passable
             *
             * @param mapRows {Number} Number of rows of blocks in the map
             * @param mapCol {Number} Number of cols of blocks in a map
             // eg, 50x50 tile map has 10x10 5-tile-blocks
             *
             * @returns map an Array of Arrays of map descriptions, as described above
             */
            var mapDescriptionGenerate = function(mapRows, mapCols){
                // If at (row, col) = (0, 0), pretend that up and left are SOLID
                // If row = 0, pretend up is SOLID
                // If col = 0, pretend left is SOLID
                var map = [];
                for (var row = 0; row < mapRows; row++){
                    map.push([]);
                    var up; // these are strings eg, "SOLID"
                    var left;
                    for (var col = 0; col< mapCols; col++){
                        if (row  == 0){
                            if (col ==0){ // if (i, j) = (0, 0)
                                up = "SOLID";
                                left = "SOLID";
                            } else {
                                up = "SOLID";
                                left = map[row][col-1];
                            }
                        }
                        else if (col == 0){ // will not have the case (i, j) = (0, 0)
                            up = map[row-1][col];
                            left = "SOLID";
                        } else { // all other cases
                            up = map[row-1][col];
                            left = map[row][col-1];
                        }
                        // find intersection
                        var possibilitiesFromUp = BlockSuccessors[up].down;
                        var possibilitiesFromUpKeys = Object.keys(possibilitiesFromUp);
                        var possibilitiesFromLeft = BlockSuccessors[left].right;
                        var possibilities = {};
                        var sumProbabilities = 0;

                        // edge cases
                        var edgeCase = false;
                        if (row == mapRows -1){
                            edgeCase = true;
                            if (col == mapCols - 1){ // bottom right cell
                                var allowed = {
                                    "SOLID":1,
                                    "UP_LEFT":1
                                }
                            } else { // bottom row
                                var allowed = {
                                    "SOLID":1,
                                    "HORIZONTAL":1,
                                    "T_UP": 1,
                                    "UP_RIGHT":1,
                                    "UP_LEFT":1
                                }
                            }
                        } else if (col == mapCols -1){ // rightmost Column
                            edgeCase = true;
                            var allowed = {
                                "SOLID":1,
                                "VERTICAL":1,
                                "T_LEFT":1,
                                "UP_LEFT":1,
                                "DOWN_LEFT":1
                            }
                        }
                        if (edgeCase){
                            var allowedKeys = Object.keys(allowed);
                            for (var i = 0; i<allowedKeys.length; i++){
                                var key = allowedKeys[i];
                                if ((key in possibilitiesFromLeft)&&(key in possibilitiesFromUp)) {
                                    var probability = allowed[key] * possibilitiesFromLeft[key] * possibilitiesFromUp[key];
                                    sumProbabilities += probability;
                                    possibilities[key] = probability;
                                }
                            }
                        } else {
                            for (var i = 0; i<possibilitiesFromUpKeys.length; i++){
                                var key = possibilitiesFromUpKeys[i];
                                if (key in possibilitiesFromLeft){
                                    var probability = possibilitiesFromLeft[key]*possibilitiesFromUp[key];
                                    sumProbabilities += probability;
                                    possibilities[key] = probability;
                                }
                            }
                        }
                        var possibilitiesKeys = Object.keys(possibilities);
                        var possibilitiesProbRanges = [];
                        var probRange = 0;
                        for (var i = 0; i<possibilitiesKeys.length; i++){
                            var key = possibilitiesKeys[i];
                            var newProb = possibilities[key]/sumProbabilities;
                            possibilities[key] = newProb; // don't actually need to do this
                            probRange += newProb;
                            possibilitiesProbRanges.push(probRange);
                        }

                        // get random number
                        var rand = Math.random();
                        var index;
                        for (var i = 0; i<possibilitiesKeys.length; i++){
                            if (rand<possibilitiesProbRanges[i]){
                                index = i;
                                break;
                            }
                        }
                        var newBlock = possibilitiesKeys[index];
                        if (!newBlock){
                            newBlock = "SOLID"; // sometimes happens for the last cell
                        }
                        map[row].push(newBlock);
                    }
                }
                return map
            };

            /**
             * Similar to mapGenerate, it generates a map description with no roads
             * to be used in the map drawing tool to create custom maps
             *
             * @param mapRows {Number} Number of rows of blocks in the map
             * @param mapCol {Number} Number of cols of blocks in a map
             // eg, 50x50 tile map has 10x10 5-tile-blocks
             *
             * @returns map an Array of Arrays of map descriptions, as described in mapGenerate
             */
            var emptyMapDescriptionGenerate = function(mapRows, mapCols) {
                var map = [];
                for (var row = 0; row < mapRows; row++) {
                    map.push([])
                    for (var col = 0; col < mapCols; col++) {
                        map[row].push("SOLID");
                    }
                }
                return map;
            };

            /**
             * Generates an actual map (in this case with no roads)
             * @param mapRows {Number} Number of rows of blocks in the map
             * @param mapCol {Number} Number of cols of blocks in a map
             // eg, 50x50 tile map has 10x10 5-tile-blocks
             *
             * @returns map an Array of Arrays of map tile numbers
             */
            var emptyMapGenerate = function(numRows, numCols){
                return mapDecode(emptyMapDescriptionGenerate(numRows, numCols));
            };

            /**
             * Generates an actual map based on a map description
             * @param mapDescription Description of a map as described in mapDescriptionGenerate
             *
             * @returns map an Array of Arrays of map tile numbers
             */
            var mapDecode = function(mapDescription){
                var data = [];
                for (var rowNum = 0; rowNum<mapDescription.length; rowNum++){
                    for (var blockRowNum = 0; blockRowNum<blockHeight; blockRowNum++){
                        var rowData = [];
                        for (var colNum = 0; colNum<mapDescription[rowNum].length; colNum++){
                            var description = mapDescription[rowNum][colNum];
                            var descriptionArray = Blocks[description];
                            rowData = rowData.concat(descriptionArray[blockRowNum]);
                        }
                        data.push(rowData);
                    };
                }
                return data;
            };

            /**
             * Generates a random numRows*numCols map
             */
            var mapGenerate = function(numRows, numCols){
                var mapEmpty = true;
//                while (mapEmpty){ To disallow empty maps; has an issue of causing the webpage to hang for certain inputs
//                    var map = mapDecode(mapDescriptionGenerate(numRows, numCols));
//                    if ((map.length === Blocks.SOLID.length)&&(map[0].length === Blocks.SOLID.length)){ // for the 5x5 map that will always be empty
//                        break;
//                    }
//                    for (var i = 0; i<map.length; i++){
//                        for (var j = 0; j<map[0].length; j++){
//                            if (STRAIGHT_ROADS.has(map[i][j])){
//                                mapEmpty = false;
//                            }
//                        }
//                    }
//                }
                var map = mapDecode(mapDescriptionGenerate(numRows, numCols));

                combineDisconnected(map);
                markIntersections(map, false);
                return map;
            }

            /** http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
             * Randomize array element order in-place.
             * Using Durstenfeld shuffle algorithm.
             *
             * Used in combineDisconnected
             */
            function shuffleArray(array) {
                for (var i = array.length - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    var temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
                return array;
            }

            /**
             * Combines disconnected components in a map
             * // mutates
             * @param map
             */
            var combineDisconnected = function(map){
                var components = findComponents(map, TileType.PASSABLE);
                if (components.length>1){
                    shuffleArray(components);
                    for (var compNum = 0; compNum < components.length-1; compNum++){
                        var first = components[compNum];
                        var second = components[compNum+1];
                        // select a point in 1st and 2nd component
                        // join them
                        var point1 = first[Math.floor(first.length/2)];
                        var point2 = second[Math.floor(second.length/2)];
                        var x1 = point1[1];
                        var y1 = point1[0];
                        var x2 = point2[1];
                        var y2 = point2[0];

                        var center = findBlockCenter(map, y1, x1);
                        if (center.length === 0){
                            console.log("point1", y1, x1, center);
                        }
                        x1 = center[1];
                        y1 = center[0];
                        center = findBlockCenter(map, y2, x2);
                        if (center.length === 0){
                            console.log("point2",y2, x2, center);
                        }

                        x2 = center[1];
                        y2 = center[0];

                        var x_start;
                        var x_end;
                        var y_start;
                        var y_end;
                        var x_hold;
                        var y_hold;
                        if (x1<x2){
                            x_start = x1;
                            x_end = x2;
                        } else {
                            x_start = x2;
                            x_end = x1;
                        }
                        if (y1<y2){
                            y_start = y1;
                            y_end = y2;
                        } else {
                            y_start = y2;
                            y_end = y1;
                        }

                        if ((x1<x2 && y1<y2) || (x2<x1 && y2<y1)){ //low high
                            x_hold = x_start;
                            y_hold = y_end;
                        } else{ //low low
                            x_hold = x_start;
                            y_hold = y_start;
                        }


                        for (var i = x_start; i<x_end+1; i++){
                            if (map[y_hold][i] === IMPASSABLE){
                                map[y_hold][i] = HOR_ROAD; // use 5 for debugging
                            }
                        }

                        for (var j = y_start; j<y_end+1; j++){
                            if (map[j][x_hold] === IMPASSABLE){
                                map[j][x_hold] = VER_ROAD; // use 5 for debugging
                            }
                        }
                    }
                }

            };

            /**
             *  ****Only to be used on unpadded graphs***
             *  Given a map and a cell (row, col), finds the center of
             *  the block the cell is in, if that block is not a SOLID
             *
             *  Assumes that the map uses the same blocks size as saved
             *  in the Blocks object
             * @param map
             * @param row
             * @param col
             * @returns [row col] of the center if found; [] otherwise
             */
            var findBlockCenter = function(map, row, col){
                if (row>map.length-1 || row<0){
                    return [];
                }
                if (col>map[0].length-1 || col<0){
                    return [];
                }
                var blockHeight = Blocks.SOLID.length;
                var blockWidth = Blocks.SOLID[0].length;
                var row_start = row - Math.floor((blockHeight-1)/2);
                var col_start = col - Math.floor((blockWidth-1)/2);
                var row_end = row + Math.ceil((blockHeight-1)/2);
                var col_end = col + Math.ceil((blockWidth-1)/2);
                if (row_start<0){
                    row_start = 0;
                }
                if (row_end>map.length-1){
                    row_end = map.length-1;
                }
                if (col_start<0){
                    col_start = 0;
                }
                if (col_end>map[0].length-1){
                    col_end = map[0].length-1;
                }
                for (var i = row_start; i<row_end+1; i++){
                    for (var j = col_start; j<col_end+1; j++){
                        if ((i%blockHeight)=== Math.floor((blockHeight-1)/2) &&
                                (j%blockWidth)=== Math.floor((blockWidth-1)/2)){ //if i and j are in the middle of the block
                            if (TileType.PASSABLE.has(map[i][j])){
                                return [i,j]
                            }
                        }
                    }
                }
                return [];
            };

            /**
             * Adds padding to a map, based on how big the map actually is and how big
             * we want it to be
             *
             * for invalid sizes, just returns the original map
             *
             * @param map
             * @param numTilesRow
             * @param numTilesCol
             * @returns {Array}
             */

            var addPadding = function(map, numTilesRow, numTilesCol){
                // for invalid sizes, just return the original map,
                if (numTilesRow<map.length || numTilesCol<map[0].length){
                    return map;
                }

                // to offset the effects of even blocks size, the padding adds
                // extra empty tiles to the top and left :)
                var paddedMap = [];
                var paddingTop = Math.ceil((numTilesRow - map.length)/2);
                var paddingBottom = Math.floor((numTilesRow - map.length)/2);
                var paddingLeft = Math.ceil((numTilesCol - map[0].length)/2);
                var paddingRight = Math.floor((numTilesCol - map[0].length)/2);

                // add top padding
                for (var i = 0; i<paddingTop; i++){
                    paddedMap.push([]);
                    for (var j=0; j<numTilesCol; j++){
                        paddedMap[i].push(IMPASSABLE);
                    }
                }

                // add left and right paddings
                for (var i = paddingTop; i<paddingTop+map.length; i++){
                    paddedMap.push([]);
                    // left padding
                    for (j=0; j<paddingLeft; j++){
                        paddedMap[i].push(IMPASSABLE);
                    }

                    // middle portion
                    paddedMap[i] = paddedMap[i].concat(map[i-paddingTop]); //map's i is shifted by paddingTop

                    // right padding
                    for (j=paddingLeft+map[0].length; j<numTilesCol; j++){
                        paddedMap[i].push(IMPASSABLE);
                    }
                }

                // bottom padding
                for (var i = paddingTop+map.length; i<numTilesRow; i++){
                    paddedMap.push([]);
                    for (var j=0; j<numTilesCol; j++){
                        paddedMap[i].push(IMPASSABLE);
                    }
                }

                return paddedMap;
            };


            /**
             * Checks whether the (row,col) cell is an intersection
             * @param map
             * @param i row
             * @param j col
             * @returns {*[isIntersection, intersectionID]}
             */
            var checkIntersection = function(map, i, j){
                if (!map[i] || !map[i][j]){
                    return [false, IMPASSABLE];
                }

                var up    = 2;
                var down  = 3;
                var left  = 5;
                var right = 7;

                var tileType = TileType.PASSABLE;
                var ID = -1;

                if (tileType.has(map[i][j])){
                    if ((i>0) && tileType.has(map[i-1][j])) {//up
                        ID *= up;
                    }
                    if ((j>0) && tileType.has(map[i][j-1])){//left
                        ID *= left;
                    }
                    if ((j<map[0].length-1) && tileType.has(map[i][j+1])){//right
                        ID *= right;
                    }
                    if ((i<map.length-1) && tileType.has(map[i+1][j])){//down
                        ID *= down;
                    }
                }
                if ((ID != -1) && (ID in INTERSECTION_TILENUMBER_TO_NAME)){
                    return [true, ID];  // ID is new map value
                }
                return [false, map[i][j]]; // just return the old value
            };

            /**
             * For the (i,j) cell, checks whether that cell, the cell above, below, to the
             * left and to the right of it are intersections
             * @param map
             * @param i row
             * @param j col
             * @returns {*[own, up, down, left, right]}
             */
            var checkIntersectionOfSurroundings = function(map, i, j){
                var own = checkIntersection(map, i, j);
                var up = checkIntersection(map, i-1, j);
                var down = checkIntersection(map, i+1, j);
                var left = checkIntersection(map, i, j-1);
                var right = checkIntersection(map, i, j+1);

                return [own, up, down, left, right];
            };


            /**
             * Given an road of unknown direction (UNKNOWN_ROAD), figures out which direction it should be
             * based on its surroundings
             *
             * needs to be preceeded/followed by checking for intersections
             * ie, (i,j) should not be an intersection
             *
             * mutates the map
             *
             * @param map
             * @param i
             * @param j
             */
            var defineTileDirection = function(map, i, j){

                if (!map[i] || !map[i][j]){
                    return;
                }

                var tileType = TileType.PASSABLE;

                // in case the tile direction is undefined
                // horizontals will stay horizontal and verticals will stay vertical
                // however, incorrect labels will be fixed
                if (ROADS.has(map[i][j])){
                    map[i][j] = HOR_ROAD; // initially define it as horizontal

                    // if it has a vertical component, define it as vertical
                    if ((i>0) && tileType.has(map[i-1][j])) {//up
                        map[i][j] = VER_ROAD;
                    }
                    if ((i<map.length-1) && tileType.has(map[i+1][j])){//down
                        map[i][j] = VER_ROAD;
                    }
                }
            };

            /**
             * Given an road of unknown direction (UNKNOWN_ROAD), figures out which direction it should be
             * based on its surroundings, and does the same for its 4 surrounding tiles
             *
             * needs to be preceeded/followed by checking for intersections
             * ie, (i,j) should not be an intersection
             *
             * mutates the map
             *
             * @param map
             * @param i
             * @param j
             */
            var defineTileDirectionOfSurroundings = function(map, i, j){
                defineTileDirection(map, i, j);
                defineTileDirection(map, i-1, j);
                defineTileDirection(map, i+1, j);
                defineTileDirection(map, i, j-1);
                defineTileDirection(map, i, j+1);

            };

            /**
             * Checks if a cell should be a stop tile or not (if it has an intersection to the side)
             */
            var checkForStop = function(map, i, j) {
                if (TileType.PASSABLE.has(map[i][j])) {
                    if ((i > 0) && (map[i - 1][j] in INTERSECTION_TILENUMBER_TO_NAME )) {//up
                        return [true, VER_STOP];
                    }
                    if ((j > 0) && (map[i][j - 1] in INTERSECTION_TILENUMBER_TO_NAME )) {//left
                        return [true, HOR_STOP];
                    }
                    if ((j < map[0].length - 1) && (map[i][j+1] in INTERSECTION_TILENUMBER_TO_NAME)) {//right
                        return [true, HOR_STOP];
                    }
                    if ((i < map.length - 1) && (map[i+1][j] in INTERSECTION_TILENUMBER_TO_NAME)) {//down
                        return [true, VER_STOP];
                    }
                }
                return [false, null];
            };


            /**
             * Given a map and a cell (i,j),
             * if it is to mark: looks at the 4 surroundings and either marks them as stop tiles appropriately
             * if it is to remove: marks itself as an unknown tile (UNKNOWN_ROAD) and removes surrounding stop
             *      tiles appropriately (if they belong to another intersection, they will not be removed)
             *
             * mutates
             * stop tile = tiles that the player stops at next to an intersection
             */

            var markOrRemoveIntersectionStopTiles = function(map, i, j, mark, updateMap){
                if (!map[i] || !map[i][j]){
                    return;
                }

                if (map[i][j] in INTERSECTION_TILENUMBER_TO_NAME){ // it is an intersection
                    if (!mark) { // we are removing this, so might as well unmark it here
                        map[i][j] = UNKNOWN_ROAD; // since only removing roads does this, it's going to be fixed later
                        var [isStop, type] = checkForStop(map, i, j);
                        if (isStop) { // it is actually a stop for some other intersection
                            if (type === HOR_STOP) {
                                if (updateMap) {
                                    $("[data-row='" + (i) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("horStop");
                                }
                                map[i][j] = HOR_STOP;
                            } else {
                                if (updateMap) {
                                    $("[data-row='" + (i) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("verStop");
                                }
                                map[i][j] = VER_STOP;

                            }
                        } else {
                            if (updateMap) {
                                $("[data-row='" + (i) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("black");
                            }
                        }
                    }
                    if ((i>0) && ROADS.has(map[i-1][j])) {//up
                        if (mark){
                            if(updateMap) {
                                $("[data-row='" + (i - 1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("verStop");
                            }
                            map[i-1][j] = VER_STOP;
                        } else {
                            var [isStop, type] = checkForStop(map, i-1, j);
                            if (isStop){ // it is actually a stop for some other intersection
                                if (type === HOR_STOP){
                                    if (updateMap){
                                        $("[data-row='" + (i - 1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("horStop");
                                    }
                                    map[i-1][j] = HOR_STOP;
                                } else {
                                    if (updateMap){
                                        $("[data-row='" + (i - 1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("verStop");
                                    }
                                    map[i-1][j] = VER_STOP;

                                }
                            } else {
                                if(updateMap) {
                                    $("[data-row='" + (i - 1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("black");
                                }
                                map[i-1][j] = VER_ROAD;
                            }

                        }

                    }
                    if ((j>0) && ROADS.has(map[i][j-1])){//left
                        if (mark){
                            if(updateMap) {
                                $("[data-row='" + (i) + "'][data-col='" + (j - 1) + "']").removeClass().addClass("cell").addClass("horStop");
                            }
                            map[i][j-1] = HOR_STOP;
                        } else{
                            var [isStop, type] = checkForStop(map, i, j-1);
                            if (isStop){ // it is actually a stop for some other intersection
                                if (type === HOR_STOP){
                                    if (updateMap){
                                        $("[data-row='" + (i) + "'][data-col='" + (j-1) + "']").removeClass().addClass("cell").addClass("horStop");
                                    }
                                    map[i][j-1] = HOR_STOP;
                                } else {
                                    if (updateMap){
                                        $("[data-row='" + (i) + "'][data-col='" + (j-1) + "']").removeClass().addClass("cell").addClass("verStop");
                                    }
                                    map[i][j-1] = VER_STOP;

                                }
                            } else {
                                if(updateMap) {
                                    $("[data-row='" + (i) + "'][data-col='" + (j-1) + "']").removeClass().addClass("cell").addClass("black");
                                }
                                map[i][j-1] = VER_ROAD;
                            }
                        }

                    }
                    if ((j<map[0].length-1) && ROADS.has(map[i][j+1])){//right
                        if (mark){
                            if(updateMap) {
                                $("[data-row='" + (i) + "'][data-col='" + (j + 1) + "']").removeClass().addClass("cell").addClass("horStop");
                            }
                            map[i][j+1] = HOR_STOP;
                        } else {
                            var [isStop, type] = checkForStop(map, i, j+1);
                            if (isStop){ // it is actually a stop for some other intersection
                                if (type === HOR_STOP){
                                    if (updateMap){
                                        $("[data-row='" + (i) + "'][data-col='" + (j+1) + "']").removeClass().addClass("cell").addClass("horStop");
                                    }
                                    map[i][j+1] = HOR_STOP;
                                } else {
                                    if (updateMap){
                                        $("[data-row='" + (i) + "'][data-col='" + (j+1) + "']").removeClass().addClass("cell").addClass("verStop");
                                    }
                                    map[i][j+1] = VER_STOP;

                                }
                            } else {
                                if(updateMap) {
                                    $("[data-row='" + (i) + "'][data-col='" + (j+1) + "']").removeClass().addClass("cell").addClass("black");
                                }
                                map[i][j+1] = VER_ROAD;
                            }
                        }

                    }
                    if ((i<map.length-1) && ROADS.has(map[i+1][j])){//down
                        if (mark){
                            if(updateMap) {
                                $("[data-row='" + (i + 1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("verStop");
                            }
                            map[i+1][j] = VER_STOP;

                        } else {
                            var [isStop, type] = checkForStop(map, i+1, j);
                            if (isStop){ // it is actually a stop for some other intersection
                                if (type === HOR_STOP){
                                    if (updateMap){
                                        $("[data-row='" + (i+1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("horStop");
                                    }
                                    map[i+1][j] = HOR_STOP;
                                } else {
                                    if (updateMap){
                                        $("[data-row='" + (i+1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("verStop");
                                    }
                                    map[i+1][j] = VER_STOP;

                                }
                            } else {
                                if(updateMap) {
                                    $("[data-row='" + (i+1) + "'][data-col='" + (j) + "']").removeClass().addClass("cell").addClass("black");
                                }
                                map[i+1][j] = VER_ROAD;
                            }
                        }
                    }
                }
            };

            /**
             * Given a map, looks for intersections and marks it
             *  mutates the map
             * @param map
             * @param display
             */
            var markIntersections = function(map, display){

                for (var i = 0; i< map.length; i++){ // i is y is row
                    for (var j = 0; j<map[0].length; j++){ // j is x is col
                        var [isIntersection, intersectionID] = checkIntersection(map, i, j);
                        if(isIntersection){
                            map[i][j] = intersectionID;
                            markOrRemoveIntersectionStopTiles(map, i, j, true, display);
                        }
                    }
                }
            };


        </script>
    </div>

    <div id="displayMap">
        <script>
            /**
                displays the map as a canvas element inside #mapboard
            */
            var displayMap = function(map){

                $("#mapboard").html("");
                var width = map[0].length;         // width in pixels
                var height = map.length;


                var makeCell = function(color, row, col){
                    return "<div class='"+color+" cell' data-row='"+row+"' data-col='"+col+"' style='height:"+cellSize+"px;width:"+cellSize+"px;'></div>";

                }
                var mapDrawing = "<div id='mapContainer'>";
                for (var j=0; j<width; j++){
                    mapDrawing = mapDrawing.concat("<div class='col'>");
                    for (var i=0; i<height; i++){
                        mapDrawing = mapDrawing.concat("<div class='row'>");
                        if (TileType.PASSABLE.has(map[i][j])){
                            if(map[i][j] === DEBUGGING){ //debugging
                                mapDrawing = mapDrawing.concat(makeCell("white",i,j));
                            } else if (map[i][j] in INTERSECTION_TILENUMBER_TO_NAME) { // intersection
                                mapDrawing = mapDrawing.concat(makeCell("intersection", i, j));
                            } else if (STOPS.has(map[i][j])){ // stop
                                if (map[i][j] === HOR_STOP){
                                    mapDrawing = mapDrawing.concat(makeCell("horStop",i,j));
                                } else {
                                    mapDrawing = mapDrawing.concat(makeCell("verStop",i,j));
                                }

                            } else {
                                mapDrawing = mapDrawing.concat(makeCell("black",i,j));
                            }
                        } else {
                            mapDrawing = mapDrawing.concat(makeCell("grey",i,j));
                        }
                        mapDrawing = mapDrawing.concat("</div>");
                    }
                    mapDrawing = mapDrawing.concat("</div>");
                }
                mapDrawing = mapDrawing.concat("</div>");
                $("#mapboard").html(mapDrawing);
            }
            
        </script>
    </div>
    <div id="manualMapEdit">
        <script type="text/javascript">
            $(function(){
                // Handlers for manually editing the map

                $('#start-edit').click(function(){
                    $('#edit-buttons-show-hide').css({
                        display: 'none'
                    });
                    $('#edit-button').css({
                        display: 'block'
                    });
                })

                var editingAdd = false;
                var editingRemove = false;


                var dragging = false;

                $("#reset").prop("disabled",true);

                $("#add").click(function(){
                    editingAdd = true;
                    editingRemove = false;
                    $("#add").prop("disabled",true);
                    $("#remove").prop("disabled",false);
                    $("#reset").prop("disabled",false);
                });
                $("#remove").click(function(){
                    editingAdd = false;
                    editingRemove = true;
                    $("#add").prop("disabled",false);
                    $("#remove").prop("disabled",true);
                    $("#reset").prop("disabled",false);
                });

                $("#reset").click(function(){
                    editingAdd = false;
                    editingRemove = false;
                    $("#add").prop("disabled",false);
                    $("#remove").prop("disabled",false);
                    $("#reset").prop("disabled",true);
                    currentMap = $.extend(true, [], currentMapSafetyCopy);
                    displayMap(currentMap);
                });

                $("#done").click(function(){
                    editingAdd = false;
                    editingRemove = false;
                    $("#add").prop("disabled",false);
                    $("#remove").prop("disabled",false);
                    $("#reset").prop("disabled",true);
//                    markIntersections(currentMap, true);
                    currentMapSafetyCopy = $.extend(true, [], currentMap);

                    // hide away edit options
                    $('#edit-buttons-show-hide').css({
                        display: 'block'
                    });
                    $('#edit-button').css({
                        display: 'none'
                    });
                });

                $("body").on("mousedown","#mapContainer", function(evt){
                    evt.preventDefault();
                    if (editingAdd || editingRemove){
                        dragging = true;
                    }
                });

                $("body").on("mouseup","#mapContainer", function(evt){
                    evt.preventDefault();
                    dragging = false;
                });

                $("body").on("mousemove ",".cell", function(evt) {
                    evt.preventDefault();

                    var row = $(this).data("row");
                    var col = $(this).data("col");
                    if (dragging) {
                        if (editingAdd) {
                            $(this).removeClass();
                            $(this).addClass("cell").addClass("black");
                            currentMap[row][col] = UNKNOWN_ROAD;
                            // When a new road is drawn, at first we can't tell if it is horizontal or vertical
                            // We initially mark it as horizontal and then
                            // we check the surroundings to figure it out
                            // figure out = if a tile is unlabelled, see its surroundings to see which one it should be
                            //              if it is a intersection, that will be fixed later
                            //              we also look at the surrounding tiles to make sure to correct it if it was
                            //              previously mislabelled (the initial horizontal labelling)
                            // Note that unless a tile is stranded (in which case it is okay for it to be a horizontal tile)
                            // it will always have another tile next to it. If that is a new tile, the check will fix it; otherwise
                            // there will not be an issue to begin with
                            //

                            defineTileDirectionOfSurroundings(currentMap, row, col);
                            var newIntersections = checkIntersectionOfSurroundings(currentMap, row, col);
                            if (newIntersections[0][0]){ // own
                                $(this).removeClass();
                                $(this).addClass("cell").addClass("intersection");
                                currentMap[row][col] = newIntersections[0][1];
                                markOrRemoveIntersectionStopTiles(currentMap, row, col, true, true);
                            }
                            if (newIntersections[1][0]){ //up
                                $("[data-row='"+(row-1)+"'][data-col='"+col+"']").removeClass();
                                $("[data-row='"+(row-1)+"'][data-col='"+col+"']").addClass("cell").addClass("intersection");
                                currentMap[row-1][col] = newIntersections[1][1];
                                markOrRemoveIntersectionStopTiles(currentMap, row-1, col, true, true);
                            }
                            if (newIntersections[2][0]){ //down
                                $("[data-row='"+(row+1)+"'][data-col='"+col+"']").removeClass();
                                $("[data-row='"+(row+1)+"'][data-col='"+col+"']").addClass("cell").addClass("intersection");
                                currentMap[row+1][col] = newIntersections[2][1];
                                markOrRemoveIntersectionStopTiles(currentMap, row+1, col, true, true);
                            }
                            if (newIntersections[3][0]){ //left
                                $("[data-row='"+row+"'][data-col='"+(col-1)+"']").removeClass();
                                $("[data-row='"+row+"'][data-col='"+(col-1)+"']").addClass("cell").addClass("intersection");
                                currentMap[row][col-1] = newIntersections[3][1];
                                markOrRemoveIntersectionStopTiles(currentMap, row, col-1, true, true);
                            }
                            if (newIntersections[4][0]){ //right
                                $("[data-row='"+row+"'][data-col='"+(col+1)+"']").removeClass();
                                $("[data-row='"+row+"'][data-col='"+(col+1)+"']").addClass("cell").addClass("intersection");
                                currentMap[row][col+1] = newIntersections[4][1];
                                markOrRemoveIntersectionStopTiles(currentMap, row, col+1, true, true);
                            }
                        } else if (editingRemove) {
                            if (currentMap[row][col] in INTERSECTION_TILENUMBER_TO_NAME){
                                markOrRemoveIntersectionStopTiles(currentMap, row, col, false, true);
                            }
                            $(this).removeClass();
                            $(this).addClass("cell").addClass("grey");
                            currentMap[row][col] = IMPASSABLE; // get rid of current road

                            var newIntersections = checkIntersectionOfSurroundings(currentMap, row, col);
                            // if intersections need to be removed
                            if (!newIntersections[1][0] && currentMap[row-1] && (currentMap[row-1][col] in INTERSECTION_TILENUMBER_TO_NAME)){ //up
                                $("[data-row='"+(row-1)+"'][data-col='"+col+"']").removeClass().addClass("cell").addClass("black");
                                markOrRemoveIntersectionStopTiles(currentMap, row-1, col, false, true);
                                currentMap[row-1][col] = UNKNOWN_ROAD;
                            }
                            if (!newIntersections[2][0] && currentMap[row+1] && (currentMap[row+1][col] in INTERSECTION_TILENUMBER_TO_NAME)){ //down
                                $("[data-row='"+(row+1)+"'][data-col='"+col+"']").removeClass().addClass("cell").addClass("black");
                                markOrRemoveIntersectionStopTiles(currentMap, row+1, col, false, true);
                                currentMap[row+1][col] = UNKNOWN_ROAD;
                            }
                            if (!newIntersections[3][0] && (currentMap[row][col-1] in INTERSECTION_TILENUMBER_TO_NAME)){ //left
                                $("[data-row='"+row+"'][data-col='"+(col-1)+"']").removeClass().addClass("cell").addClass("black");
                                markOrRemoveIntersectionStopTiles(currentMap, row, col-1, false, true);
                                currentMap[row][col-1] = UNKNOWN_ROAD;
                            }
                            if (!newIntersections[4][0] && (currentMap[row][col+1] in INTERSECTION_TILENUMBER_TO_NAME)){ //right
                                $("[data-row='"+row+"'][data-col='"+(col+1)+"']").removeClass().addClass("cell").addClass("black");
                                markOrRemoveIntersectionStopTiles(currentMap, row, col+1, false, true);
                                currentMap[row][col+1] = UNKNOWN_ROAD;
                            }
                            defineTileDirectionOfSurroundings(currentMap, row, col);
                        }
                    }

                });
            });



        </script>
    </div>
    <div id="dat.gui">
        <script type="text/javascript">
            /**
             * Create a new random map

                height, width integer
             */
            var createNewMap = function(height, width){
                var map = mapGenerate(height,width);
                unpaddedMap = map;
                currentMap = addPadding(map, numTilesRow, numTilesCol);
                displayMap(currentMap);
            };

            /**
             * Function that allows saving the map to disk as a csv file
             * @param map
             */
            var saveMap = function(map){
                var csvContent = "data:text/csv;charset=utf-8,";
                map.forEach(function(infoArray, index){
                    dataString = infoArray.join(",");
                    csvContent += index < map.length ? dataString+ "\n" : dataString;

                });


                var encodedUri = encodeURI(csvContent);
                var link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                var millis = new Date();
                var filename = "cs_map_" + millis.getTime() + ".csv";

                link.setAttribute("download", filename);

                link.click(); // This will download the data file named "{file name}.csv".
            };


            var gui = new dat.GUI({width:350});

            // The dat.gui interface for inputting parameters to tweek the map
            var mapTweeker = function() {
                this.mapNameToLoad = "cs_map_1463203007411";
                this.cellSize = cellSize;

                this.numTilesCol = numTilesCol;
                this.numTilesRow = numTilesRow;
                this.blockWidth = blockWidth;
                this.blockHeight = blockHeight;
                this.density = 0;
                this.deadends = false;
                this.resizeCurrent = function(){
                    cellSize = this.cellSize;
                    displayMap(currentMap);
                };
                
                this.IMPASSABLE = IMPASSABLE;
                this.VERTICAL = VER_ROAD;
                this.HORIZONTAL = HOR_ROAD;
                this.HOR_STOP = HOR_STOP;
                this.VER_STOP = VER_STOP;
                this.PLUS = INTERSECTION_NAME_TO_TILENUMBER["PLUS"];
                this.T_LEFT = INTERSECTION_NAME_TO_TILENUMBER["T_LEFT"];
                this.T_RIGHT = INTERSECTION_NAME_TO_TILENUMBER["T_RIGHT"];
                this.T_UP = INTERSECTION_NAME_TO_TILENUMBER["T_UP"];
                this.T_DOWN = INTERSECTION_NAME_TO_TILENUMBER["T_DOWN"];
                this.UP_LEFT = INTERSECTION_NAME_TO_TILENUMBER["UP_LEFT"];
                this.UP_RIGHT = INTERSECTION_NAME_TO_TILENUMBER["UP_RIGHT"];
                this.DOWN_RIGHT = INTERSECTION_NAME_TO_TILENUMBER["DOWN_RIGHT"];
                this.DOWN_LEFT = INTERSECTION_NAME_TO_TILENUMBER["DOWN_LEFT"];
                this.resetToDefault = function(){
                    this.IMPASSABLE = IMPASSABLE;
                    this.VERTICAL = VER_ROAD;
                    this.HORIZONTAL = HOR_ROAD;
                    this.HOR_STOP = HOR_STOP;
                    this.VER_STOP = VER_STOP;
                    this.PLUS = INTERSECTION_NAME_TO_TILENUMBER["PLUS"];
                    this.T_LEFT = INTERSECTION_NAME_TO_TILENUMBER["T_LEFT"];
                    this.T_RIGHT = INTERSECTION_NAME_TO_TILENUMBER["T_RIGHT"];
                    this.T_UP = INTERSECTION_NAME_TO_TILENUMBER["T_UP"];
                    this.T_DOWN = INTERSECTION_NAME_TO_TILENUMBER["T_DOWN"];
                    this.UP_LEFT = INTERSECTION_NAME_TO_TILENUMBER["UP_LEFT"];
                    this.UP_RIGHT = INTERSECTION_NAME_TO_TILENUMBER["UP_RIGHT"];
                    this.DOWN_RIGHT = INTERSECTION_NAME_TO_TILENUMBER["DOWN_RIGHT"];
                    this.DOWN_LEFT = INTERSECTION_NAME_TO_TILENUMBER["DOWN_LEFT"];

                    for (var i = 0; i < gui.__folders.defineTileMapping.__controllers.length; i++) {
                        gui.__folders.defineTileMapping.__controllers[i].updateDisplay();
                    }

                };

                this.userDefined_Mapping = function(){
                    var newMap = [];
                    for (var i= 0; i<currentMap.length; i++){
                        newMap.push([]);
                        for (var j=0; j<currentMap[0].length; j++){
                            switch(currentMap[i][j]){
                                case IMPASSABLE:
                                    newMap[i][j] = this.IMPASSABLE;
                                    break;
                                case VER_ROAD:
                                    newMap[i][j] = this.VERTICAL;
                                    break;
                                case HOR_ROAD:
                                    newMap[i][j] = this.HORIZONTAL;
                                    break;
                                case HOR_STOP:
                                    newMap[i][j] = this.HOR_STOP;
                                    break;
                                case VER_STOP:
                                    newMap[i][j] = this.VER_STOP;
                                    break;
                                case INTERSECTION_NAME_TO_TILENUMBER["PLUS"]:
                                    newMap[i][j] = this.PLUS;
                                    break;
                                case INTERSECTION_NAME_TO_TILENUMBER["T_LEFT"]:
                                    newMap[i][j] = this.T_LEFT;
                                    break;
                                case INTERSECTION_NAME_TO_TILENUMBER["T_RIGHT"]:
                                    newMap[i][j] = this.T_RIGHT;
                                    break;
                                case INTERSECTION_NAME_TO_TILENUMBER["T_UP"]:
                                    newMap[i][j] = this.T_UP;
                                    break;
                                case INTERSECTION_NAME_TO_TILENUMBER["T_DOWN"]:
                                    newMap[i][j] = this.T_DOWN;
                                    break;
                                case INTERSECTION_NAME_TO_TILENUMBER["UP_LEFT"]:
                                    newMap[i][j] = this.UP_LEFT;
                                    break;
                                case INTERSECTION_NAME_TO_TILENUMBER["UP_RIGHT"]:
                                    newMap[i][j] = this.UP_RIGHT;
                                    break;
                                case INTERSECTION_NAME_TO_TILENUMBER["DOWN_RIGHT"]:
                                    newMap[i][j] = this.DOWN_RIGHT;
                                    break;
                                case INTERSECTION_NAME_TO_TILENUMBER["DOWN_LEFT"]:
                                    newMap[i][j] = this.DOWN_LEFT;
                                    break;

                            }
                        }
                    }
                    saveMap(newMap);
                };
                
                this.update = function(){
                    density = this.density;
                    if (density === 0){
                        density = 1;
                    } else if (density<0){
                        density = 1/(-density);
                    } else {
                        density = density;
                    }
                    if (this.deadends){
                        PathDown.YES.SOLID = .5;
                        PathToRight.YES.SOLID = .5;
                    } else {
                        PathDown.YES.SOLID = 0;
                        PathToRight.YES.SOLID = 0;
                    }
                    PathDown.YES.VERTICAL = 1/density;
                    PathDown.NO.HORIZONTAL = 1/density;
                    PathToRight.YES.HORIZONTAL = 1/density;
                    PathToRight.NO.VERTICAL = 1/density;
                    PathDown.NO.SOLID = .5/density;
                    PathToRight.NO.SOLID = .5/density;
                    PathDown.YES.PLUS = .25*(density +1);
                    PathToRight.YES.PLUS = .25*(density+1);



                    numTilesCol = Math.round(this.numTilesCol);
                    numTilesRow = Math.round(this.numTilesRow);
                    blockHeight = Math.round(this.blockHeight);
                    blockWidth = Math.round(this.blockWidth);
                    BlockTypesMaker(blockHeight,blockWidth);
                    cellSize = this.cellSize;
                    numCols = Math.floor(this.numTilesCol/blockWidth);
                    numRows = Math.floor(this.numTilesRow/blockHeight)
                    createNewMap(numRows,numCols);
                    currentMapSafetyCopy  = $.extend(true, [], currentMap);
                };
                this.load = function(){
                    $("#mapboard").html("");
                    mapName = this.mapNameToLoad;
                    var ext = mapName.slice(-4);
                    if (!(ext === ".csv")){
                        mapName += ".csv";
                    }
                    $.get(mapName, function(data) {
                        var rows = data.split("\n");

                        var parsedMap = [];
                        for (var i = 0; i<rows.length-1; i++){
                            var cols = rows[i].split(",");
                            parsedMap.push(cols);
                            for (var j = 0; j<parsedMap[i].length;j++){
                                parsedMap[i][j] = parseInt(parsedMap[i][j]);
                            }
                        }

                        currentMap = parsedMap;
                        // display parsed map
                        displayMap(parsedMap);
                        currentMapSafetyCopy  = $.extend(true, [], currentMap);
                    });



                };

                this.cleanSlate = function(){
                    currentMap = emptyMapGenerate(numRows, numCols);
                    displayMap(currentMap);
                    currentMapSafetyCopy  = $.extend(true, [], currentMap);

                }
                this.default_Mapping = function(){
                    saveMap(currentMap);
                };
                
            };
        </script>
    </div>
    <script>
        window.onload = function() {
            // Making a new dat.gui interface

            var mapTweekerUI = new mapTweeker();


            var f1 = gui.addFolder("tweek");

            f1.add(mapTweekerUI, 'numTilesRow', 1, 100).step(1);
            f1.add(mapTweekerUI, 'numTilesCol', 1, 100).step(1);

            f1.add(mapTweekerUI, 'blockHeight', 1, 20).step(1);
            f1.add(mapTweekerUI, 'blockWidth', 1, 20).step(1);

            f1.add(mapTweekerUI, 'density', -10, 10).step(1);
            f1.add(mapTweekerUI, 'deadends');

            f1.add(mapTweekerUI, 'update');
            f1.add(mapTweekerUI, 'cleanSlate');

            var f4 = gui.addFolder("defineTileMapping");
            f4.add(mapTweekerUI, "IMPASSABLE");
            f4.add(mapTweekerUI, "VERTICAL");
            f4.add(mapTweekerUI, "HORIZONTAL");
            f4.add(mapTweekerUI, "VER_STOP");
            f4.add(mapTweekerUI, "HOR_STOP");
            f4.add(mapTweekerUI, "PLUS");
            f4.add(mapTweekerUI, "T_LEFT");
            f4.add(mapTweekerUI, "T_RIGHT");
            f4.add(mapTweekerUI, "T_UP");
            f4.add(mapTweekerUI, "T_DOWN");
            f4.add(mapTweekerUI, "UP_LEFT");
            f4.add(mapTweekerUI, "UP_RIGHT");
            f4.add(mapTweekerUI, "DOWN_RIGHT");
            f4.add(mapTweekerUI, "DOWN_LEFT");
            f4.add(mapTweekerUI, "resetToDefault");

            var f3 = gui.addFolder("resizeDisplay");
            f3.add(mapTweekerUI, 'cellSize', 1, 20);
            f3.add(mapTweekerUI, 'resizeCurrent');

            var f5 = gui.addFolder("save");
            f5.add(mapTweekerUI, 'default_Mapping');
            f5.add(mapTweekerUI, "userDefined_Mapping");

            var f2 = gui.addFolder("load");
            f2.add(mapTweekerUI, 'mapNameToLoad');
            f2.add(mapTweekerUI, 'load');

            f1.closed = false;
            f3.closed = false;

            BlockTypesMaker(blockHeight,blockWidth);
            createNewMap(numRows, numCols);
            currentMapSafetyCopy  =$.extend(true, [], currentMap);

        };
    </script>
</div>
<div id="show-row-col">
    <script>
        $(function(){
            // to show the position of a cell on hover
            $('body').on('mouseenter', '.cell', function(event){
                var row = $(this).data("row");
                var col = $(this).data("col");
                var x= $(this).position().left;
                var y= $(this).position().top;
                $("#cell-row-col").html("("+row+","+col+")");
                $("#cell-row-col").css({
                    display: 'block',
                    position: 'absolute',
                    top: y-20,
                    left: x+20
                })
            });
            $('body').on('mouseleave', '#mapContainer', function(event){
                $("#cell-row-col").css({
                    display: 'none',
                })
            });
        });
    </script>
</div>
</body>
</html>